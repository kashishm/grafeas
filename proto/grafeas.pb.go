// Code generated by protoc-gen-go. DO NOT EDIT.
// source: v1alpha1/proto/grafeas.proto

/*
Package grafeas is a generated protocol buffer package.

It is generated from these files:
	v1alpha1/proto/grafeas.proto

It has these top-level messages:
	CreateProjectRequest
	GetProjectRequest
	ListProjectsRequest
	DeleteProjectRequest
	GetOccurrenceRequest
	ListOccurrencesRequest
	DeleteOccurrenceRequest
	CreateOccurrenceRequest
	UpdateOccurrenceRequest
	GetNoteRequest
	GetOccurrenceNoteRequest
	ListNotesRequest
	DeleteNoteRequest
	CreateNoteRequest
	UpdateNoteRequest
	ListNoteOccurrencesRequest
	ListProjectsResponse
	ListNoteOccurrencesResponse
	ListNotesResponse
	ListOccurrencesResponse
	ListOperationsResponse
	UpdateOperationRequest
	CreateOperationRequest
	Project
	OperationMetadata
	Artifact
	AttestationAuthority
	BuildDetails
	BuildProvenance
	BuildSignature
	BuildType
	Command
	Deployable
	DockerImage
	Discovery
	FileHashes
	Hash
	Note
	Occurrence
	PackageManager
	PgpSignedAttestation
	Source
	RepoSource
	StorageSource
	VulnerabilityType
	SourceContext
	AliasContext
	CloudRepoSourceContext
	GerritSourceContext
	GitSourceContext
	RepoId
	ProjectRepoId
*/
package grafeas

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import google_protobuf "github.com/golang/protobuf/ptypes/empty"
import _ "google.golang.org/genproto/googleapis/api/annotations"
import google_protobuf2 "google.golang.org/genproto/protobuf/field_mask"
import google_protobuf3 "github.com/golang/protobuf/ptypes/timestamp"
import google_longrunning "google.golang.org/genproto/googleapis/longrunning"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

// Public key formats
type BuildSignature_KeyType int32

const (
	// `KeyType` is not set.
	BuildSignature_KEY_TYPE_UNSPECIFIED BuildSignature_KeyType = 0
	// `PGP ASCII Armored` public key.
	BuildSignature_PGP_ASCII_ARMORED BuildSignature_KeyType = 1
	// `PKIX PEM` public key.
	BuildSignature_PKIX_PEM BuildSignature_KeyType = 2
)

var BuildSignature_KeyType_name = map[int32]string{
	0: "KEY_TYPE_UNSPECIFIED",
	1: "PGP_ASCII_ARMORED",
	2: "PKIX_PEM",
}
var BuildSignature_KeyType_value = map[string]int32{
	"KEY_TYPE_UNSPECIFIED": 0,
	"PGP_ASCII_ARMORED":    1,
	"PKIX_PEM":             2,
}

func (x BuildSignature_KeyType) String() string {
	return proto.EnumName(BuildSignature_KeyType_name, int32(x))
}
func (BuildSignature_KeyType) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{29, 0} }

// Types of platforms.
type Deployable_Deployment_Platform int32

const (
	// Unknown
	Deployable_Deployment_PLATFORM_UNSPECIFIED Deployable_Deployment_Platform = 0
	// Google Container Engine
	Deployable_Deployment_GKE Deployable_Deployment_Platform = 1
	// Google App Engine: Flexible Environment
	Deployable_Deployment_FLEX Deployable_Deployment_Platform = 2
	// Custom user-defined platform
	Deployable_Deployment_CUSTOM Deployable_Deployment_Platform = 3
)

var Deployable_Deployment_Platform_name = map[int32]string{
	0: "PLATFORM_UNSPECIFIED",
	1: "GKE",
	2: "FLEX",
	3: "CUSTOM",
}
var Deployable_Deployment_Platform_value = map[string]int32{
	"PLATFORM_UNSPECIFIED": 0,
	"GKE":    1,
	"FLEX":   2,
	"CUSTOM": 3,
}

func (x Deployable_Deployment_Platform) String() string {
	return proto.EnumName(Deployable_Deployment_Platform_name, int32(x))
}
func (Deployable_Deployment_Platform) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor0, []int{32, 0, 0}
}

// Instructions from dockerfile
type DockerImage_Layer_Directive int32

const (
	// Default value for unsupported/missing directive
	DockerImage_Layer_DIRECTIVE_UNSPECIFIED DockerImage_Layer_Directive = 0
	// https://docs.docker.com/reference/builder/#maintainer
	DockerImage_Layer_MAINTAINER DockerImage_Layer_Directive = 1
	// https://docs.docker.com/reference/builder/#run
	DockerImage_Layer_RUN DockerImage_Layer_Directive = 2
	// https://docs.docker.com/reference/builder/#cmd
	DockerImage_Layer_CMD DockerImage_Layer_Directive = 3
	// https://docs.docker.com/reference/builder/#label
	DockerImage_Layer_LABEL DockerImage_Layer_Directive = 4
	// https://docs.docker.com/reference/builder/#expose
	DockerImage_Layer_EXPOSE DockerImage_Layer_Directive = 5
	// https://docs.docker.com/reference/builder/#env
	DockerImage_Layer_ENV DockerImage_Layer_Directive = 6
	// https://docs.docker.com/reference/builder/#add
	DockerImage_Layer_ADD DockerImage_Layer_Directive = 7
	// https://docs.docker.com/reference/builder/#copy
	DockerImage_Layer_COPY DockerImage_Layer_Directive = 8
	// https://docs.docker.com/reference/builder/#entrypoint
	DockerImage_Layer_ENTRYPOINT DockerImage_Layer_Directive = 9
	// https://docs.docker.com/reference/builder/#volume
	DockerImage_Layer_VOLUME DockerImage_Layer_Directive = 10
	// https://docs.docker.com/reference/builder/#user
	DockerImage_Layer_USER DockerImage_Layer_Directive = 11
	// https://docs.docker.com/reference/builder/#workdir
	DockerImage_Layer_WORKDIR DockerImage_Layer_Directive = 12
	// https://docs.docker.com/reference/builder/#arg
	DockerImage_Layer_ARG DockerImage_Layer_Directive = 13
	// https://docs.docker.com/reference/builder/#onbuild
	DockerImage_Layer_ONBUILD DockerImage_Layer_Directive = 14
	// https://docs.docker.com/reference/builder/#stopsignal
	DockerImage_Layer_STOPSIGNAL DockerImage_Layer_Directive = 15
	// https://docs.docker.com/reference/builder/#healthcheck
	DockerImage_Layer_HEALTHCHECK DockerImage_Layer_Directive = 16
	// https://docs.docker.com/reference/builder/#shell
	DockerImage_Layer_SHELL DockerImage_Layer_Directive = 17
)

var DockerImage_Layer_Directive_name = map[int32]string{
	0:  "DIRECTIVE_UNSPECIFIED",
	1:  "MAINTAINER",
	2:  "RUN",
	3:  "CMD",
	4:  "LABEL",
	5:  "EXPOSE",
	6:  "ENV",
	7:  "ADD",
	8:  "COPY",
	9:  "ENTRYPOINT",
	10: "VOLUME",
	11: "USER",
	12: "WORKDIR",
	13: "ARG",
	14: "ONBUILD",
	15: "STOPSIGNAL",
	16: "HEALTHCHECK",
	17: "SHELL",
}
var DockerImage_Layer_Directive_value = map[string]int32{
	"DIRECTIVE_UNSPECIFIED": 0,
	"MAINTAINER":            1,
	"RUN":                   2,
	"CMD":                   3,
	"LABEL":                 4,
	"EXPOSE":                5,
	"ENV":                   6,
	"ADD":                   7,
	"COPY":                  8,
	"ENTRYPOINT":            9,
	"VOLUME":                10,
	"USER":                  11,
	"WORKDIR":               12,
	"ARG":                   13,
	"ONBUILD":               14,
	"STOPSIGNAL":            15,
	"HEALTHCHECK":           16,
	"SHELL":                 17,
}

func (x DockerImage_Layer_Directive) String() string {
	return proto.EnumName(DockerImage_Layer_Directive_name, int32(x))
}
func (DockerImage_Layer_Directive) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor0, []int{33, 0, 0}
}

// Specifies the hash algorithm, if any.
type Hash_HashType int32

const (
	// No hash requested.
	Hash_NONE Hash_HashType = 0
	// A sha256 hash.
	Hash_SHA256 Hash_HashType = 1
)

var Hash_HashType_name = map[int32]string{
	0: "NONE",
	1: "SHA256",
}
var Hash_HashType_value = map[string]int32{
	"NONE":   0,
	"SHA256": 1,
}

func (x Hash_HashType) String() string {
	return proto.EnumName(Hash_HashType_name, int32(x))
}
func (Hash_HashType) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{36, 0} }

// This must be 1:1 with members of our oneofs, it can be used for filtering
// Note and Occurrence on their kind.
type Note_Kind int32

const (
	// Unknown
	Note_KIND_UNSPECIFIED Note_Kind = 0
	Note_ATTESTATION      Note_Kind = 1
	// The note and occurrence represent a package vulnerability.
	Note_PACKAGE_VULNERABILITY Note_Kind = 2
	// The note and occurrence assert build provenance.
	Note_BUILD_DETAILS Note_Kind = 3
	// This represents an image basis relationship.
	Note_IMAGE_BASIS Note_Kind = 4
	// This represents a package installed via a package manager.
	Note_PACKAGE_MANAGER Note_Kind = 5
	// The note and occurrence track deployment events.
	Note_DEPLOYABLE Note_Kind = 6
	// The note and occurrence track the initial discovery status of a resource.
	Note_DISCOVERY Note_Kind = 7
)

var Note_Kind_name = map[int32]string{
	0: "KIND_UNSPECIFIED",
	1: "ATTESTATION",
	2: "PACKAGE_VULNERABILITY",
	3: "BUILD_DETAILS",
	4: "IMAGE_BASIS",
	5: "PACKAGE_MANAGER",
	6: "DEPLOYABLE",
	7: "DISCOVERY",
}
var Note_Kind_value = map[string]int32{
	"KIND_UNSPECIFIED":      0,
	"ATTESTATION":           1,
	"PACKAGE_VULNERABILITY": 2,
	"BUILD_DETAILS":         3,
	"IMAGE_BASIS":           4,
	"PACKAGE_MANAGER":       5,
	"DEPLOYABLE":            6,
	"DISCOVERY":             7,
}

func (x Note_Kind) String() string {
	return proto.EnumName(Note_Kind_name, int32(x))
}
func (Note_Kind) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{37, 0} }

// Instruction set architectures supported by various package managers.
type PackageManager_Architecture int32

const (
	// Unknown architecture
	PackageManager_ARCHITECTURE_UNSPECIFIED PackageManager_Architecture = 0
	// X86 architecture
	PackageManager_X86 PackageManager_Architecture = 1
	// X64 architecture
	PackageManager_X64 PackageManager_Architecture = 2
)

var PackageManager_Architecture_name = map[int32]string{
	0: "ARCHITECTURE_UNSPECIFIED",
	1: "X86",
	2: "X64",
}
var PackageManager_Architecture_value = map[string]int32{
	"ARCHITECTURE_UNSPECIFIED": 0,
	"X86": 1,
	"X64": 2,
}

func (x PackageManager_Architecture) String() string {
	return proto.EnumName(PackageManager_Architecture_name, int32(x))
}
func (PackageManager_Architecture) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor0, []int{39, 0}
}

// Type (e.g. schema) of the attestation payload that was signed.
type PgpSignedAttestation_ContentType int32

const (
	// ContentType is not set.
	PgpSignedAttestation_CONTENT_TYPE_UNSPECIFIED PgpSignedAttestation_ContentType = 0
	// Atomic format attestation signature. See
	// https://github.com/containers/image/blob/8a5d2f82a6e3263290c8e0276c3e0f64e77723e7/docs/atomic-signature.md
	// The payload extracted from `signature` is a JSON blob conforming to the
	// linked schema.
	PgpSignedAttestation_SIMPLE_SIGNING_JSON PgpSignedAttestation_ContentType = 1
)

var PgpSignedAttestation_ContentType_name = map[int32]string{
	0: "CONTENT_TYPE_UNSPECIFIED",
	1: "SIMPLE_SIGNING_JSON",
}
var PgpSignedAttestation_ContentType_value = map[string]int32{
	"CONTENT_TYPE_UNSPECIFIED": 0,
	"SIMPLE_SIGNING_JSON":      1,
}

func (x PgpSignedAttestation_ContentType) String() string {
	return proto.EnumName(PgpSignedAttestation_ContentType_name, int32(x))
}
func (PgpSignedAttestation_ContentType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor0, []int{40, 0}
}

// Note provider-assigned severity/impact ranking
type VulnerabilityType_Severity int32

const (
	// Unknown Impact
	VulnerabilityType_SEVERITY_UNSPECIFIED VulnerabilityType_Severity = 0
	// Minimal Impact
	VulnerabilityType_MINIMAL VulnerabilityType_Severity = 1
	// Low Impact
	VulnerabilityType_LOW VulnerabilityType_Severity = 2
	// Medium Impact
	VulnerabilityType_MEDIUM VulnerabilityType_Severity = 3
	// High Impact
	VulnerabilityType_HIGH VulnerabilityType_Severity = 4
	// Critical Impact
	VulnerabilityType_CRITICAL VulnerabilityType_Severity = 5
)

var VulnerabilityType_Severity_name = map[int32]string{
	0: "SEVERITY_UNSPECIFIED",
	1: "MINIMAL",
	2: "LOW",
	3: "MEDIUM",
	4: "HIGH",
	5: "CRITICAL",
}
var VulnerabilityType_Severity_value = map[string]int32{
	"SEVERITY_UNSPECIFIED": 0,
	"MINIMAL":              1,
	"LOW":                  2,
	"MEDIUM":               3,
	"HIGH":                 4,
	"CRITICAL":             5,
}

func (x VulnerabilityType_Severity) String() string {
	return proto.EnumName(VulnerabilityType_Severity_name, int32(x))
}
func (VulnerabilityType_Severity) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor0, []int{44, 0}
}

// Whether this is an ordinary package version or a
// sentinel MIN/MAX version.
type VulnerabilityType_Version_VersionKind int32

const (
	// A standard package version, defined by the other fields.
	VulnerabilityType_Version_NORMAL VulnerabilityType_Version_VersionKind = 0
	// A special version representing negative infinity,
	// other fields are ignored.
	VulnerabilityType_Version_MINIMUM VulnerabilityType_Version_VersionKind = 1
	// A special version representing positive infinity,
	// other fields are ignored.
	VulnerabilityType_Version_MAXIMUM VulnerabilityType_Version_VersionKind = 2
)

var VulnerabilityType_Version_VersionKind_name = map[int32]string{
	0: "NORMAL",
	1: "MINIMUM",
	2: "MAXIMUM",
}
var VulnerabilityType_Version_VersionKind_value = map[string]int32{
	"NORMAL":  0,
	"MINIMUM": 1,
	"MAXIMUM": 2,
}

func (x VulnerabilityType_Version_VersionKind) String() string {
	return proto.EnumName(VulnerabilityType_Version_VersionKind_name, int32(x))
}
func (VulnerabilityType_Version_VersionKind) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor0, []int{44, 0, 0}
}

// The type of an alias.
type AliasContext_Kind int32

const (
	// Unknown.
	AliasContext_KIND_UNSPECIFIED AliasContext_Kind = 0
	// Git tag.
	AliasContext_FIXED AliasContext_Kind = 1
	// Git branch.
	AliasContext_MOVABLE AliasContext_Kind = 2
	// Used to specify non-standard aliases. For example, if a Git repo has a
	// ref named "refs/foo/bar".
	AliasContext_OTHER AliasContext_Kind = 4
)

var AliasContext_Kind_name = map[int32]string{
	0: "KIND_UNSPECIFIED",
	1: "FIXED",
	2: "MOVABLE",
	4: "OTHER",
}
var AliasContext_Kind_value = map[string]int32{
	"KIND_UNSPECIFIED": 0,
	"FIXED":            1,
	"MOVABLE":          2,
	"OTHER":            4,
}

func (x AliasContext_Kind) String() string {
	return proto.EnumName(AliasContext_Kind_name, int32(x))
}
func (AliasContext_Kind) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{46, 0} }

// Request to insert a new Project.
type CreateProjectRequest struct {
	// The name of the project of the form
	// "projects/{project_id}"
	Name string `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
}

func (m *CreateProjectRequest) Reset()                    { *m = CreateProjectRequest{} }
func (m *CreateProjectRequest) String() string            { return proto.CompactTextString(m) }
func (*CreateProjectRequest) ProtoMessage()               {}
func (*CreateProjectRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

func (m *CreateProjectRequest) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

// Request to get a Project.
type GetProjectRequest struct {
	// The name of the project of the form
	// "projects/{project_id}"
	Name string `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
}

func (m *GetProjectRequest) Reset()                    { *m = GetProjectRequest{} }
func (m *GetProjectRequest) String() string            { return proto.CompactTextString(m) }
func (*GetProjectRequest) ProtoMessage()               {}
func (*GetProjectRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *GetProjectRequest) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

// Request to list projects.
type ListProjectsRequest struct {
	// The filter expression.
	Filter string `protobuf:"bytes,1,opt,name=filter" json:"filter,omitempty"`
	// Number of projects to return in the list.
	PageSize int32 `protobuf:"varint,2,opt,name=page_size,json=pageSize" json:"page_size,omitempty"`
	// Token to provide to skip to a particular spot in the list.
	PageToken string `protobuf:"bytes,3,opt,name=page_token,json=pageToken" json:"page_token,omitempty"`
}

func (m *ListProjectsRequest) Reset()                    { *m = ListProjectsRequest{} }
func (m *ListProjectsRequest) String() string            { return proto.CompactTextString(m) }
func (*ListProjectsRequest) ProtoMessage()               {}
func (*ListProjectsRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

func (m *ListProjectsRequest) GetFilter() string {
	if m != nil {
		return m.Filter
	}
	return ""
}

func (m *ListProjectsRequest) GetPageSize() int32 {
	if m != nil {
		return m.PageSize
	}
	return 0
}

func (m *ListProjectsRequest) GetPageToken() string {
	if m != nil {
		return m.PageToken
	}
	return ""
}

// Request to delete a project
type DeleteProjectRequest struct {
	// The name of the project of the form
	// "projects/{project_id}"
	Name string `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
}

func (m *DeleteProjectRequest) Reset()                    { *m = DeleteProjectRequest{} }
func (m *DeleteProjectRequest) String() string            { return proto.CompactTextString(m) }
func (*DeleteProjectRequest) ProtoMessage()               {}
func (*DeleteProjectRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

func (m *DeleteProjectRequest) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

// Request to get a Occurrenceg.
type GetOccurrenceRequest struct {
	// The name of the occurrence of the form
	// "projects/{project_id}/occurrences/{OCCURRENCE_ID}"
	Name string `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
}

func (m *GetOccurrenceRequest) Reset()                    { *m = GetOccurrenceRequest{} }
func (m *GetOccurrenceRequest) String() string            { return proto.CompactTextString(m) }
func (*GetOccurrenceRequest) ProtoMessage()               {}
func (*GetOccurrenceRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

func (m *GetOccurrenceRequest) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

// Request to list occurrences.
type ListOccurrencesRequest struct {
	// This contains the project Id for example: projects/{project_id}.
	Parent string `protobuf:"bytes,5,opt,name=parent" json:"parent,omitempty"`
	// The filter expression.
	Filter string `protobuf:"bytes,2,opt,name=filter" json:"filter,omitempty"`
	// Number of occurrences to return in the list.
	PageSize int32 `protobuf:"varint,3,opt,name=page_size,json=pageSize" json:"page_size,omitempty"`
	// Token to provide to skip to a particular spot in the list.
	PageToken string `protobuf:"bytes,4,opt,name=page_token,json=pageToken" json:"page_token,omitempty"`
}

func (m *ListOccurrencesRequest) Reset()                    { *m = ListOccurrencesRequest{} }
func (m *ListOccurrencesRequest) String() string            { return proto.CompactTextString(m) }
func (*ListOccurrencesRequest) ProtoMessage()               {}
func (*ListOccurrencesRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5} }

func (m *ListOccurrencesRequest) GetParent() string {
	if m != nil {
		return m.Parent
	}
	return ""
}

func (m *ListOccurrencesRequest) GetFilter() string {
	if m != nil {
		return m.Filter
	}
	return ""
}

func (m *ListOccurrencesRequest) GetPageSize() int32 {
	if m != nil {
		return m.PageSize
	}
	return 0
}

func (m *ListOccurrencesRequest) GetPageToken() string {
	if m != nil {
		return m.PageToken
	}
	return ""
}

// Request to delete a occurrence
type DeleteOccurrenceRequest struct {
	// The name of the occurrence in the form of
	// "projects/{project_id}/occurrences/{OCCURRENCE_ID}"
	Name string `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
}

func (m *DeleteOccurrenceRequest) Reset()                    { *m = DeleteOccurrenceRequest{} }
func (m *DeleteOccurrenceRequest) String() string            { return proto.CompactTextString(m) }
func (*DeleteOccurrenceRequest) ProtoMessage()               {}
func (*DeleteOccurrenceRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{6} }

func (m *DeleteOccurrenceRequest) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

// Request to insert a new occurrence.
type CreateOccurrenceRequest struct {
	// This field contains the project Id for example: "projects/{project_id}"
	Parent string `protobuf:"bytes,3,opt,name=parent" json:"parent,omitempty"`
	// The occurrence to be inserted
	Occurrence *Occurrence `protobuf:"bytes,2,opt,name=occurrence" json:"occurrence,omitempty"`
}

func (m *CreateOccurrenceRequest) Reset()                    { *m = CreateOccurrenceRequest{} }
func (m *CreateOccurrenceRequest) String() string            { return proto.CompactTextString(m) }
func (*CreateOccurrenceRequest) ProtoMessage()               {}
func (*CreateOccurrenceRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{7} }

func (m *CreateOccurrenceRequest) GetParent() string {
	if m != nil {
		return m.Parent
	}
	return ""
}

func (m *CreateOccurrenceRequest) GetOccurrence() *Occurrence {
	if m != nil {
		return m.Occurrence
	}
	return nil
}

// Request to update an existing occurrence
type UpdateOccurrenceRequest struct {
	// The name of the occurrence.
	// Should be of the form "projects/{project_id}/occurrences/{OCCURRENCE_ID}".
	Name string `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	// The updated occurrence.
	Occurrence *Occurrence `protobuf:"bytes,2,opt,name=occurrence" json:"occurrence,omitempty"`
	// The fields to update.
	UpdateMask *google_protobuf2.FieldMask `protobuf:"bytes,3,opt,name=update_mask,json=updateMask" json:"update_mask,omitempty"`
}

func (m *UpdateOccurrenceRequest) Reset()                    { *m = UpdateOccurrenceRequest{} }
func (m *UpdateOccurrenceRequest) String() string            { return proto.CompactTextString(m) }
func (*UpdateOccurrenceRequest) ProtoMessage()               {}
func (*UpdateOccurrenceRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{8} }

func (m *UpdateOccurrenceRequest) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *UpdateOccurrenceRequest) GetOccurrence() *Occurrence {
	if m != nil {
		return m.Occurrence
	}
	return nil
}

func (m *UpdateOccurrenceRequest) GetUpdateMask() *google_protobuf2.FieldMask {
	if m != nil {
		return m.UpdateMask
	}
	return nil
}

// Request to get a Note.
type GetNoteRequest struct {
	// The name of the note in the form of
	// "providers/{provider_id}/notes/{NOTE_ID}"
	Name string `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
}

func (m *GetNoteRequest) Reset()                    { *m = GetNoteRequest{} }
func (m *GetNoteRequest) String() string            { return proto.CompactTextString(m) }
func (*GetNoteRequest) ProtoMessage()               {}
func (*GetNoteRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{9} }

func (m *GetNoteRequest) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

// Request to get the note to which this occurrence is attached.
type GetOccurrenceNoteRequest struct {
	// The name of the occurrence in the form
	// "projects/{project_id}/occurrences/{OCCURRENCE_ID}"
	Name string `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
}

func (m *GetOccurrenceNoteRequest) Reset()                    { *m = GetOccurrenceNoteRequest{} }
func (m *GetOccurrenceNoteRequest) String() string            { return proto.CompactTextString(m) }
func (*GetOccurrenceNoteRequest) ProtoMessage()               {}
func (*GetOccurrenceNoteRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{10} }

func (m *GetOccurrenceNoteRequest) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

// Request to list notes.
type ListNotesRequest struct {
	// This field contains the project ID for example: "projects/{project_id}".
	Parent string `protobuf:"bytes,5,opt,name=parent" json:"parent,omitempty"`
	// The filter expression.
	Filter string `protobuf:"bytes,2,opt,name=filter" json:"filter,omitempty"`
	// Number of notes to return in the list.
	PageSize int32 `protobuf:"varint,3,opt,name=page_size,json=pageSize" json:"page_size,omitempty"`
	// Token to provide to skip to a particular spot in the list.
	PageToken string `protobuf:"bytes,4,opt,name=page_token,json=pageToken" json:"page_token,omitempty"`
}

func (m *ListNotesRequest) Reset()                    { *m = ListNotesRequest{} }
func (m *ListNotesRequest) String() string            { return proto.CompactTextString(m) }
func (*ListNotesRequest) ProtoMessage()               {}
func (*ListNotesRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{11} }

func (m *ListNotesRequest) GetParent() string {
	if m != nil {
		return m.Parent
	}
	return ""
}

func (m *ListNotesRequest) GetFilter() string {
	if m != nil {
		return m.Filter
	}
	return ""
}

func (m *ListNotesRequest) GetPageSize() int32 {
	if m != nil {
		return m.PageSize
	}
	return 0
}

func (m *ListNotesRequest) GetPageToken() string {
	if m != nil {
		return m.PageToken
	}
	return ""
}

// Request to delete a note
type DeleteNoteRequest struct {
	// The name of the note in the form of
	// "providers/{provider_id}/notes/{NOTE_ID}"
	Name string `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
}

func (m *DeleteNoteRequest) Reset()                    { *m = DeleteNoteRequest{} }
func (m *DeleteNoteRequest) String() string            { return proto.CompactTextString(m) }
func (*DeleteNoteRequest) ProtoMessage()               {}
func (*DeleteNoteRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{12} }

func (m *DeleteNoteRequest) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

// Request to insert a new note
type CreateNoteRequest struct {
	// This field contains the project Id for example:
	// "project/{project_id}
	Parent string `protobuf:"bytes,4,opt,name=parent" json:"parent,omitempty"`
	// The ID to use for this note.
	NoteId string `protobuf:"bytes,2,opt,name=note_id,json=noteId" json:"note_id,omitempty"`
	// The Note to be inserted
	Note *Note `protobuf:"bytes,3,opt,name=note" json:"note,omitempty"`
}

func (m *CreateNoteRequest) Reset()                    { *m = CreateNoteRequest{} }
func (m *CreateNoteRequest) String() string            { return proto.CompactTextString(m) }
func (*CreateNoteRequest) ProtoMessage()               {}
func (*CreateNoteRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{13} }

func (m *CreateNoteRequest) GetParent() string {
	if m != nil {
		return m.Parent
	}
	return ""
}

func (m *CreateNoteRequest) GetNoteId() string {
	if m != nil {
		return m.NoteId
	}
	return ""
}

func (m *CreateNoteRequest) GetNote() *Note {
	if m != nil {
		return m.Note
	}
	return nil
}

// Request to update an existing note
type UpdateNoteRequest struct {
	// The name of the note.
	// Should be of the form "projects/{provider_id}/notes/{note_id}".
	Name string `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	// The updated note.
	Note *Note `protobuf:"bytes,2,opt,name=note" json:"note,omitempty"`
	// The fields to update.
	UpdateMask *google_protobuf2.FieldMask `protobuf:"bytes,3,opt,name=update_mask,json=updateMask" json:"update_mask,omitempty"`
}

func (m *UpdateNoteRequest) Reset()                    { *m = UpdateNoteRequest{} }
func (m *UpdateNoteRequest) String() string            { return proto.CompactTextString(m) }
func (*UpdateNoteRequest) ProtoMessage()               {}
func (*UpdateNoteRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{14} }

func (m *UpdateNoteRequest) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *UpdateNoteRequest) GetNote() *Note {
	if m != nil {
		return m.Note
	}
	return nil
}

func (m *UpdateNoteRequest) GetUpdateMask() *google_protobuf2.FieldMask {
	if m != nil {
		return m.UpdateMask
	}
	return nil
}

// Request to list occurrences.
type ListNoteOccurrencesRequest struct {
	// The name field will contain the note name for example:
	//   "provider/{provider_id}/notes/{note_id}"
	Name string `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	// The filter expression.
	Filter string `protobuf:"bytes,2,opt,name=filter" json:"filter,omitempty"`
	// Number of notes to return in the list.
	PageSize int32 `protobuf:"varint,3,opt,name=page_size,json=pageSize" json:"page_size,omitempty"`
	// Token to provide to skip to a particular spot in the list.
	PageToken string `protobuf:"bytes,4,opt,name=page_token,json=pageToken" json:"page_token,omitempty"`
}

func (m *ListNoteOccurrencesRequest) Reset()                    { *m = ListNoteOccurrencesRequest{} }
func (m *ListNoteOccurrencesRequest) String() string            { return proto.CompactTextString(m) }
func (*ListNoteOccurrencesRequest) ProtoMessage()               {}
func (*ListNoteOccurrencesRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{15} }

func (m *ListNoteOccurrencesRequest) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *ListNoteOccurrencesRequest) GetFilter() string {
	if m != nil {
		return m.Filter
	}
	return ""
}

func (m *ListNoteOccurrencesRequest) GetPageSize() int32 {
	if m != nil {
		return m.PageSize
	}
	return 0
}

func (m *ListNoteOccurrencesRequest) GetPageToken() string {
	if m != nil {
		return m.PageToken
	}
	return ""
}

// Response including listed projects
type ListProjectsResponse struct {
	// The projects requested.
	Projects []*Project `protobuf:"bytes,1,rep,name=projects" json:"projects,omitempty"`
	// The next pagination token in the list response. It should be used as
	// `page_token` for the following request. An empty value means no more
	// results.
	NextPageToken string `protobuf:"bytes,2,opt,name=next_page_token,json=nextPageToken" json:"next_page_token,omitempty"`
}

func (m *ListProjectsResponse) Reset()                    { *m = ListProjectsResponse{} }
func (m *ListProjectsResponse) String() string            { return proto.CompactTextString(m) }
func (*ListProjectsResponse) ProtoMessage()               {}
func (*ListProjectsResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{16} }

func (m *ListProjectsResponse) GetProjects() []*Project {
	if m != nil {
		return m.Projects
	}
	return nil
}

func (m *ListProjectsResponse) GetNextPageToken() string {
	if m != nil {
		return m.NextPageToken
	}
	return ""
}

// Response including listed occurrences for a note.
type ListNoteOccurrencesResponse struct {
	// The occurrences attached to the specified note.
	Occurrences []*Occurrence `protobuf:"bytes,1,rep,name=occurrences" json:"occurrences,omitempty"`
	// Token to receive the next page of notes.
	NextPageToken string `protobuf:"bytes,2,opt,name=next_page_token,json=nextPageToken" json:"next_page_token,omitempty"`
}

func (m *ListNoteOccurrencesResponse) Reset()                    { *m = ListNoteOccurrencesResponse{} }
func (m *ListNoteOccurrencesResponse) String() string            { return proto.CompactTextString(m) }
func (*ListNoteOccurrencesResponse) ProtoMessage()               {}
func (*ListNoteOccurrencesResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{17} }

func (m *ListNoteOccurrencesResponse) GetOccurrences() []*Occurrence {
	if m != nil {
		return m.Occurrences
	}
	return nil
}

func (m *ListNoteOccurrencesResponse) GetNextPageToken() string {
	if m != nil {
		return m.NextPageToken
	}
	return ""
}

// Response including listed notes.
type ListNotesResponse struct {
	// The occurrences requested
	Notes []*Note `protobuf:"bytes,1,rep,name=notes" json:"notes,omitempty"`
	// The next pagination token in the list response. It should be used as
	// page_token for the following request. An empty value means no more result.
	NextPageToken string `protobuf:"bytes,2,opt,name=next_page_token,json=nextPageToken" json:"next_page_token,omitempty"`
}

func (m *ListNotesResponse) Reset()                    { *m = ListNotesResponse{} }
func (m *ListNotesResponse) String() string            { return proto.CompactTextString(m) }
func (*ListNotesResponse) ProtoMessage()               {}
func (*ListNotesResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{18} }

func (m *ListNotesResponse) GetNotes() []*Note {
	if m != nil {
		return m.Notes
	}
	return nil
}

func (m *ListNotesResponse) GetNextPageToken() string {
	if m != nil {
		return m.NextPageToken
	}
	return ""
}

// Response including listed active occurrences.
type ListOccurrencesResponse struct {
	// The occurrences requested.
	Occurrences []*Occurrence `protobuf:"bytes,1,rep,name=occurrences" json:"occurrences,omitempty"`
	// The next pagination token in the list response. It should be used as
	// `page_token` for the following request. An empty value means no more
	// results.
	NextPageToken string `protobuf:"bytes,2,opt,name=next_page_token,json=nextPageToken" json:"next_page_token,omitempty"`
}

func (m *ListOccurrencesResponse) Reset()                    { *m = ListOccurrencesResponse{} }
func (m *ListOccurrencesResponse) String() string            { return proto.CompactTextString(m) }
func (*ListOccurrencesResponse) ProtoMessage()               {}
func (*ListOccurrencesResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{19} }

func (m *ListOccurrencesResponse) GetOccurrences() []*Occurrence {
	if m != nil {
		return m.Occurrences
	}
	return nil
}

func (m *ListOccurrencesResponse) GetNextPageToken() string {
	if m != nil {
		return m.NextPageToken
	}
	return ""
}

// Response including listed operations.
type ListOperationsResponse struct {
	// The next pagination token in the List response. It should be used as
	// page_token for the following request. An empty value means no more results.
	NextPageToken string `protobuf:"bytes,1,opt,name=nextPageToken" json:"nextPageToken,omitempty"`
	// The operations requested.
	Operations []*google_longrunning.Operation `protobuf:"bytes,2,rep,name=operations" json:"operations,omitempty"`
}

func (m *ListOperationsResponse) Reset()                    { *m = ListOperationsResponse{} }
func (m *ListOperationsResponse) String() string            { return proto.CompactTextString(m) }
func (*ListOperationsResponse) ProtoMessage()               {}
func (*ListOperationsResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{20} }

func (m *ListOperationsResponse) GetNextPageToken() string {
	if m != nil {
		return m.NextPageToken
	}
	return ""
}

func (m *ListOperationsResponse) GetOperations() []*google_longrunning.Operation {
	if m != nil {
		return m.Operations
	}
	return nil
}

// Request for updating an existing operation
type UpdateOperationRequest struct {
	// The name of the Operation.
	// Should be of the form "projects/{provider_id}/operations/{operation_id}".
	Name string `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	// The operation to create.
	Operation *google_longrunning.Operation `protobuf:"bytes,3,opt,name=operation" json:"operation,omitempty"`
}

func (m *UpdateOperationRequest) Reset()                    { *m = UpdateOperationRequest{} }
func (m *UpdateOperationRequest) String() string            { return proto.CompactTextString(m) }
func (*UpdateOperationRequest) ProtoMessage()               {}
func (*UpdateOperationRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{21} }

func (m *UpdateOperationRequest) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *UpdateOperationRequest) GetOperation() *google_longrunning.Operation {
	if m != nil {
		return m.Operation
	}
	return nil
}

// Request for creating an operation
type CreateOperationRequest struct {
	// The projectId that this operation should be created under.
	Parent string `protobuf:"bytes,1,opt,name=parent" json:"parent,omitempty"`
	// The ID to use for this operation.
	OperationId string `protobuf:"bytes,2,opt,name=operation_id,json=operationId" json:"operation_id,omitempty"`
	// The operation to create.
	Operation *google_longrunning.Operation `protobuf:"bytes,3,opt,name=operation" json:"operation,omitempty"`
}

func (m *CreateOperationRequest) Reset()                    { *m = CreateOperationRequest{} }
func (m *CreateOperationRequest) String() string            { return proto.CompactTextString(m) }
func (*CreateOperationRequest) ProtoMessage()               {}
func (*CreateOperationRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{22} }

func (m *CreateOperationRequest) GetParent() string {
	if m != nil {
		return m.Parent
	}
	return ""
}

func (m *CreateOperationRequest) GetOperationId() string {
	if m != nil {
		return m.OperationId
	}
	return ""
}

func (m *CreateOperationRequest) GetOperation() *google_longrunning.Operation {
	if m != nil {
		return m.Operation
	}
	return nil
}

// Provides detailed description of a `Project`.
type Project struct {
	// The name of the project of the form
	// "projects/{project_id}"
	Name string `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
}

func (m *Project) Reset()                    { *m = Project{} }
func (m *Project) String() string            { return proto.CompactTextString(m) }
func (*Project) ProtoMessage()               {}
func (*Project) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{23} }

func (m *Project) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

// Metadata for all operations used and required for all operations
// that created by Container Analysis Providers
type OperationMetadata struct {
	// Output only. The time this operation was created.
	CreateTime *google_protobuf3.Timestamp `protobuf:"bytes,1,opt,name=create_time,json=createTime" json:"create_time,omitempty"`
	// Output only. The time that this operation was marked completed or failed.
	EndTime *google_protobuf3.Timestamp `protobuf:"bytes,2,opt,name=end_time,json=endTime" json:"end_time,omitempty"`
}

func (m *OperationMetadata) Reset()                    { *m = OperationMetadata{} }
func (m *OperationMetadata) String() string            { return proto.CompactTextString(m) }
func (*OperationMetadata) ProtoMessage()               {}
func (*OperationMetadata) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{24} }

func (m *OperationMetadata) GetCreateTime() *google_protobuf3.Timestamp {
	if m != nil {
		return m.CreateTime
	}
	return nil
}

func (m *OperationMetadata) GetEndTime() *google_protobuf3.Timestamp {
	if m != nil {
		return m.EndTime
	}
	return nil
}

// Artifact describes a build product.
type Artifact struct {
	// Name of the artifact. This may be the path to a binary or jar file, or in
	// the case of a container build, the name used to push the container image to
	// Google Container Registry, as presented to `docker push`.
	//
	// This field is deprecated in favor of the plural `names` field; it continues
	// to exist here to allow existing BuildProvenance serialized to json in
	// google.devtools.containeranalysis.v1alpha1.BuildDetails.provenance_bytes to
	// deserialize back into proto.
	Name string `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	// Hash or checksum value of a binary, or Docker Registry 2.0 digest of a
	// container.
	Checksum string `protobuf:"bytes,2,opt,name=checksum" json:"checksum,omitempty"`
	// Artifact ID, if any; for container images, this will be a URL by digest
	// like gcr.io/projectID/imagename@sha256:123456
	Id string `protobuf:"bytes,3,opt,name=id" json:"id,omitempty"`
	// Related artifact names. This may be the path to a binary or jar file, or in
	// the case of a container build, the name used to push the container image to
	// Google Container Registry, as presented to `docker push`. Note that a
	// single Artifact ID can have multiple names, for example if two tags are
	// applied to one image.
	Names []string `protobuf:"bytes,4,rep,name=names" json:"names,omitempty"`
}

func (m *Artifact) Reset()                    { *m = Artifact{} }
func (m *Artifact) String() string            { return proto.CompactTextString(m) }
func (*Artifact) ProtoMessage()               {}
func (*Artifact) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{25} }

func (m *Artifact) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Artifact) GetChecksum() string {
	if m != nil {
		return m.Checksum
	}
	return ""
}

func (m *Artifact) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *Artifact) GetNames() []string {
	if m != nil {
		return m.Names
	}
	return nil
}

// Note kind that represents a logical attestation "role" or "authority".  For
// example, an organization might have one AttestationAuthority for "QA" and one
// for "build".  This Note is intended to act strictly as a grouping mechanism
// for the attached Occurrences (Attestations).  This grouping mechanism also
// provides a security boundary and provides a single point of lookup to find
// all attached Attestation Occurrences, even if they don't all live in the same
// project.
type AttestationAuthority struct {
	Hint *AttestationAuthority_AttestationAuthorityHint `protobuf:"bytes,1,opt,name=hint" json:"hint,omitempty"`
}

func (m *AttestationAuthority) Reset()                    { *m = AttestationAuthority{} }
func (m *AttestationAuthority) String() string            { return proto.CompactTextString(m) }
func (*AttestationAuthority) ProtoMessage()               {}
func (*AttestationAuthority) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{26} }

func (m *AttestationAuthority) GetHint() *AttestationAuthority_AttestationAuthorityHint {
	if m != nil {
		return m.Hint
	}
	return nil
}

type AttestationAuthority_AttestationAuthorityHint struct {
	// The human readable name of this Attestation Authority, e.g. "qa".
	HumanReadableName string   `protobuf:"bytes,1,opt,name=human_readable_name,json=humanReadableName" json:"human_readable_name,omitempty"`
	Keys              []string `protobuf:"bytes,2,rep,name=keys" json:"keys,omitempty"`
}

func (m *AttestationAuthority_AttestationAuthorityHint) Reset() {
	*m = AttestationAuthority_AttestationAuthorityHint{}
}
func (m *AttestationAuthority_AttestationAuthorityHint) String() string {
	return proto.CompactTextString(m)
}
func (*AttestationAuthority_AttestationAuthorityHint) ProtoMessage() {}
func (*AttestationAuthority_AttestationAuthorityHint) Descriptor() ([]byte, []int) {
	return fileDescriptor0, []int{26, 0}
}

func (m *AttestationAuthority_AttestationAuthorityHint) GetHumanReadableName() string {
	if m != nil {
		return m.HumanReadableName
	}
	return ""
}

func (m *AttestationAuthority_AttestationAuthorityHint) GetKeys() []string {
	if m != nil {
		return m.Keys
	}
	return nil
}

type AttestationAuthority_Attestation struct {
	// The signature, generally over the `resource_url`, that verifies this
	// attestation.  The semantics of the signature veracity are ultimately
	// determined by the verification engine.
	//
	// Types that are valid to be assigned to Signature:
	//	*AttestationAuthority_Attestation_PgpSignedAttestation
	Signature isAttestationAuthority_Attestation_Signature `protobuf_oneof:"signature"`
}

func (m *AttestationAuthority_Attestation) Reset()         { *m = AttestationAuthority_Attestation{} }
func (m *AttestationAuthority_Attestation) String() string { return proto.CompactTextString(m) }
func (*AttestationAuthority_Attestation) ProtoMessage()    {}
func (*AttestationAuthority_Attestation) Descriptor() ([]byte, []int) {
	return fileDescriptor0, []int{26, 1}
}

type isAttestationAuthority_Attestation_Signature interface {
	isAttestationAuthority_Attestation_Signature()
}

type AttestationAuthority_Attestation_PgpSignedAttestation struct {
	PgpSignedAttestation *PgpSignedAttestation `protobuf:"bytes,1,opt,name=pgp_signed_attestation,json=pgpSignedAttestation,oneof"`
}

func (*AttestationAuthority_Attestation_PgpSignedAttestation) isAttestationAuthority_Attestation_Signature() {
}

func (m *AttestationAuthority_Attestation) GetSignature() isAttestationAuthority_Attestation_Signature {
	if m != nil {
		return m.Signature
	}
	return nil
}

func (m *AttestationAuthority_Attestation) GetPgpSignedAttestation() *PgpSignedAttestation {
	if x, ok := m.GetSignature().(*AttestationAuthority_Attestation_PgpSignedAttestation); ok {
		return x.PgpSignedAttestation
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*AttestationAuthority_Attestation) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _AttestationAuthority_Attestation_OneofMarshaler, _AttestationAuthority_Attestation_OneofUnmarshaler, _AttestationAuthority_Attestation_OneofSizer, []interface{}{
		(*AttestationAuthority_Attestation_PgpSignedAttestation)(nil),
	}
}

func _AttestationAuthority_Attestation_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*AttestationAuthority_Attestation)
	// signature
	switch x := m.Signature.(type) {
	case *AttestationAuthority_Attestation_PgpSignedAttestation:
		b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.PgpSignedAttestation); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("AttestationAuthority_Attestation.Signature has unexpected type %T", x)
	}
	return nil
}

func _AttestationAuthority_Attestation_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*AttestationAuthority_Attestation)
	switch tag {
	case 1: // signature.pgp_signed_attestation
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(PgpSignedAttestation)
		err := b.DecodeMessage(msg)
		m.Signature = &AttestationAuthority_Attestation_PgpSignedAttestation{msg}
		return true, err
	default:
		return false, nil
	}
}

func _AttestationAuthority_Attestation_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*AttestationAuthority_Attestation)
	// signature
	switch x := m.Signature.(type) {
	case *AttestationAuthority_Attestation_PgpSignedAttestation:
		s := proto.Size(x.PgpSignedAttestation)
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// Message encapsulating build provenance details.
type BuildDetails struct {
	// The actual provenance
	Provenance *BuildProvenance `protobuf:"bytes,1,opt,name=provenance" json:"provenance,omitempty"`
	// Serialized JSON representation of the provenance, used in generating the
	// `BuildSignature` in the corresponding Result. After verifying the
	// signature, `provenance_bytes` can be unmarshalled and compared to the
	// provenance to confirm that it is unchanged. A base64-encoded string
	// representation of the provenance bytes is used for the signature in order
	// to interoperate with openssl which expects this format for signature
	// verification.
	//
	// The serialized form is captured both to avoid ambiguity in how the
	// provenance is marshalled to json as well to prevent incompatibilities with
	// future changes.
	ProvenanceBytes string `protobuf:"bytes,2,opt,name=provenance_bytes,json=provenanceBytes" json:"provenance_bytes,omitempty"`
}

func (m *BuildDetails) Reset()                    { *m = BuildDetails{} }
func (m *BuildDetails) String() string            { return proto.CompactTextString(m) }
func (*BuildDetails) ProtoMessage()               {}
func (*BuildDetails) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{27} }

func (m *BuildDetails) GetProvenance() *BuildProvenance {
	if m != nil {
		return m.Provenance
	}
	return nil
}

func (m *BuildDetails) GetProvenanceBytes() string {
	if m != nil {
		return m.ProvenanceBytes
	}
	return ""
}

// Provenance of a build. Contains all information needed to verify the full
// details about the build from source to completion.
type BuildProvenance struct {
	// Unique identifier of the build.
	Id string `protobuf:"bytes,1,opt,name=id" json:"id,omitempty"`
	// ID of the project.
	ProjectId string `protobuf:"bytes,2,opt,name=project_id,json=projectId" json:"project_id,omitempty"`
	// Commands requested by the build.
	Commands []*Command `protobuf:"bytes,5,rep,name=commands" json:"commands,omitempty"`
	// Output of the build.
	BuiltArtifacts []*Artifact `protobuf:"bytes,6,rep,name=built_artifacts,json=builtArtifacts" json:"built_artifacts,omitempty"`
	// Time at which the build was created.
	CreateTime *google_protobuf3.Timestamp `protobuf:"bytes,7,opt,name=create_time,json=createTime" json:"create_time,omitempty"`
	// Time at which execution of the build was started.
	StartTime *google_protobuf3.Timestamp `protobuf:"bytes,8,opt,name=start_time,json=startTime" json:"start_time,omitempty"`
	// Time at which execution of the build was finished.
	FinishTime *google_protobuf3.Timestamp `protobuf:"bytes,9,opt,name=finish_time,json=finishTime" json:"finish_time,omitempty"`
	// E-mail address of the user who initiated this build. Note that this was the
	// user's e-mail address at the time the build was initiated; this address may
	// not represent the same end-user for all time.
	Creator string `protobuf:"bytes,11,opt,name=creator" json:"creator,omitempty"`
	// Google Cloud Storage bucket where logs were written.
	LogsBucket string `protobuf:"bytes,13,opt,name=logs_bucket,json=logsBucket" json:"logs_bucket,omitempty"`
	// Details of the Source input to the build.
	SourceProvenance *Source `protobuf:"bytes,14,opt,name=source_provenance,json=sourceProvenance" json:"source_provenance,omitempty"`
	// Trigger identifier if the build was triggered automatically; empty if not.
	TriggerId string `protobuf:"bytes,15,opt,name=trigger_id,json=triggerId" json:"trigger_id,omitempty"`
	// Special options applied to this build. This is a catch-all field where
	// build providers can enter any desired additional details.
	BuildOptions map[string]string `protobuf:"bytes,16,rep,name=build_options,json=buildOptions" json:"build_options,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	// Version string of the builder at the time this build was executed.
	BuilderVersion string `protobuf:"bytes,17,opt,name=builder_version,json=builderVersion" json:"builder_version,omitempty"`
}

func (m *BuildProvenance) Reset()                    { *m = BuildProvenance{} }
func (m *BuildProvenance) String() string            { return proto.CompactTextString(m) }
func (*BuildProvenance) ProtoMessage()               {}
func (*BuildProvenance) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{28} }

func (m *BuildProvenance) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *BuildProvenance) GetProjectId() string {
	if m != nil {
		return m.ProjectId
	}
	return ""
}

func (m *BuildProvenance) GetCommands() []*Command {
	if m != nil {
		return m.Commands
	}
	return nil
}

func (m *BuildProvenance) GetBuiltArtifacts() []*Artifact {
	if m != nil {
		return m.BuiltArtifacts
	}
	return nil
}

func (m *BuildProvenance) GetCreateTime() *google_protobuf3.Timestamp {
	if m != nil {
		return m.CreateTime
	}
	return nil
}

func (m *BuildProvenance) GetStartTime() *google_protobuf3.Timestamp {
	if m != nil {
		return m.StartTime
	}
	return nil
}

func (m *BuildProvenance) GetFinishTime() *google_protobuf3.Timestamp {
	if m != nil {
		return m.FinishTime
	}
	return nil
}

func (m *BuildProvenance) GetCreator() string {
	if m != nil {
		return m.Creator
	}
	return ""
}

func (m *BuildProvenance) GetLogsBucket() string {
	if m != nil {
		return m.LogsBucket
	}
	return ""
}

func (m *BuildProvenance) GetSourceProvenance() *Source {
	if m != nil {
		return m.SourceProvenance
	}
	return nil
}

func (m *BuildProvenance) GetTriggerId() string {
	if m != nil {
		return m.TriggerId
	}
	return ""
}

func (m *BuildProvenance) GetBuildOptions() map[string]string {
	if m != nil {
		return m.BuildOptions
	}
	return nil
}

func (m *BuildProvenance) GetBuilderVersion() string {
	if m != nil {
		return m.BuilderVersion
	}
	return ""
}

// Message encapsulating the signature of the verified build.
type BuildSignature struct {
	// Public key of the builder which can be used to verify that the related
	// findings are valid and unchanged. If `key_type` is empty, this defaults
	// to PEM encoded public keys.
	//
	// This field may be empty if `key_id` references an external key.
	//
	// For Cloud Container Builder based signatures, this is a PEM encoded public
	// key. To verify the Cloud Container Builder signature, place the contents of
	// this field into a file (public.pem). The signature field is base64-decoded
	// into its binary representation in signature.bin, and the provenance bytes
	// from `BuildDetails` are base64-decoded into a binary representation in
	// signed.bin. OpenSSL can then verify the signature:
	// `openssl sha256 -verify public.pem -signature signature.bin signed.bin`
	PublicKey string `protobuf:"bytes,1,opt,name=public_key,json=publicKey" json:"public_key,omitempty"`
	// Signature of the related `BuildProvenance`, encoded in a base64 string.
	Signature string `protobuf:"bytes,2,opt,name=signature" json:"signature,omitempty"`
	// An Id for the key used to sign. This could be either an Id for the key
	// stored in `public_key` (such as the Id or fingerprint for a PGP key, or the
	// CN for a cert), or a reference to an external key (such as a reference to a
	// key in Cloud Key Management Service).
	KeyId string `protobuf:"bytes,3,opt,name=key_id,json=keyId" json:"key_id,omitempty"`
	// The type of the key, either stored in `public_key` or referenced in
	// `key_id`
	KeyType BuildSignature_KeyType `protobuf:"varint,4,opt,name=key_type,json=keyType,enum=grafeas.v1alpha1.api.BuildSignature_KeyType" json:"key_type,omitempty"`
}

func (m *BuildSignature) Reset()                    { *m = BuildSignature{} }
func (m *BuildSignature) String() string            { return proto.CompactTextString(m) }
func (*BuildSignature) ProtoMessage()               {}
func (*BuildSignature) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{29} }

func (m *BuildSignature) GetPublicKey() string {
	if m != nil {
		return m.PublicKey
	}
	return ""
}

func (m *BuildSignature) GetSignature() string {
	if m != nil {
		return m.Signature
	}
	return ""
}

func (m *BuildSignature) GetKeyId() string {
	if m != nil {
		return m.KeyId
	}
	return ""
}

func (m *BuildSignature) GetKeyType() BuildSignature_KeyType {
	if m != nil {
		return m.KeyType
	}
	return BuildSignature_KEY_TYPE_UNSPECIFIED
}

// Note holding the version of the provider's builder and the signature of
// the provenance message in linked BuildDetails.
type BuildType struct {
	// Version of the builder which produced this Note.
	BuilderVersion string `protobuf:"bytes,1,opt,name=builder_version,json=builderVersion" json:"builder_version,omitempty"`
	// Signature of the build in Occurrences pointing to the Note containing this
	// `BuilderDetails`.
	Signature *BuildSignature `protobuf:"bytes,2,opt,name=signature" json:"signature,omitempty"`
}

func (m *BuildType) Reset()                    { *m = BuildType{} }
func (m *BuildType) String() string            { return proto.CompactTextString(m) }
func (*BuildType) ProtoMessage()               {}
func (*BuildType) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{30} }

func (m *BuildType) GetBuilderVersion() string {
	if m != nil {
		return m.BuilderVersion
	}
	return ""
}

func (m *BuildType) GetSignature() *BuildSignature {
	if m != nil {
		return m.Signature
	}
	return nil
}

// Command describes a step performed as part of the build pipeline.
type Command struct {
	// Name of the command, as presented on the command line, or if the command is
	// packaged as a Docker container, as presented to `docker pull`.
	Name string `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	// Environment variables set before running this Command.
	Env []string `protobuf:"bytes,2,rep,name=env" json:"env,omitempty"`
	// Command-line arguments used when executing this Command.
	Args []string `protobuf:"bytes,3,rep,name=args" json:"args,omitempty"`
	// Working directory (relative to project source root) used when running
	// this Command.
	Dir string `protobuf:"bytes,4,opt,name=dir" json:"dir,omitempty"`
	// Optional unique identifier for this Command, used in wait_for to reference
	// this Command as a dependency.
	Id string `protobuf:"bytes,5,opt,name=id" json:"id,omitempty"`
	// The ID(s) of the Command(s) that this Command depends on.
	WaitFor []string `protobuf:"bytes,6,rep,name=wait_for,json=waitFor" json:"wait_for,omitempty"`
}

func (m *Command) Reset()                    { *m = Command{} }
func (m *Command) String() string            { return proto.CompactTextString(m) }
func (*Command) ProtoMessage()               {}
func (*Command) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{31} }

func (m *Command) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Command) GetEnv() []string {
	if m != nil {
		return m.Env
	}
	return nil
}

func (m *Command) GetArgs() []string {
	if m != nil {
		return m.Args
	}
	return nil
}

func (m *Command) GetDir() string {
	if m != nil {
		return m.Dir
	}
	return ""
}

func (m *Command) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *Command) GetWaitFor() []string {
	if m != nil {
		return m.WaitFor
	}
	return nil
}

// An artifact that can be deployed in some runtime.
type Deployable struct {
	// Resource URI for the artifact being deployed.
	ResourceUri []string `protobuf:"bytes,1,rep,name=resource_uri,json=resourceUri" json:"resource_uri,omitempty"`
}

func (m *Deployable) Reset()                    { *m = Deployable{} }
func (m *Deployable) String() string            { return proto.CompactTextString(m) }
func (*Deployable) ProtoMessage()               {}
func (*Deployable) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{32} }

func (m *Deployable) GetResourceUri() []string {
	if m != nil {
		return m.ResourceUri
	}
	return nil
}

// The period during which some deployable was active in a runtime.
type Deployable_Deployment struct {
	// Identity of the user that triggered this deployment.
	UserEmail string `protobuf:"bytes,1,opt,name=user_email,json=userEmail" json:"user_email,omitempty"`
	// Beginning of the lifetime of this deployment.
	DeployTime *google_protobuf3.Timestamp `protobuf:"bytes,2,opt,name=deploy_time,json=deployTime" json:"deploy_time,omitempty"`
	// End of the lifetime of this deployment.
	UndeployTime *google_protobuf3.Timestamp `protobuf:"bytes,3,opt,name=undeploy_time,json=undeployTime" json:"undeploy_time,omitempty"`
	// Configuration used to create this deployment.
	Config string `protobuf:"bytes,8,opt,name=config" json:"config,omitempty"`
	// Address of the runtime element hosting this deployment.
	Address string `protobuf:"bytes,5,opt,name=address" json:"address,omitempty"`
	// Output only. Resource URI for the artifact being deployed taken from the
	// deployable field with the same name.
	ResourceUri []string `protobuf:"bytes,6,rep,name=resource_uri,json=resourceUri" json:"resource_uri,omitempty"`
	// Platform hosting this deployment.
	Platform Deployable_Deployment_Platform `protobuf:"varint,7,opt,name=platform,enum=grafeas.v1alpha1.api.Deployable_Deployment_Platform" json:"platform,omitempty"`
}

func (m *Deployable_Deployment) Reset()                    { *m = Deployable_Deployment{} }
func (m *Deployable_Deployment) String() string            { return proto.CompactTextString(m) }
func (*Deployable_Deployment) ProtoMessage()               {}
func (*Deployable_Deployment) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{32, 0} }

func (m *Deployable_Deployment) GetUserEmail() string {
	if m != nil {
		return m.UserEmail
	}
	return ""
}

func (m *Deployable_Deployment) GetDeployTime() *google_protobuf3.Timestamp {
	if m != nil {
		return m.DeployTime
	}
	return nil
}

func (m *Deployable_Deployment) GetUndeployTime() *google_protobuf3.Timestamp {
	if m != nil {
		return m.UndeployTime
	}
	return nil
}

func (m *Deployable_Deployment) GetConfig() string {
	if m != nil {
		return m.Config
	}
	return ""
}

func (m *Deployable_Deployment) GetAddress() string {
	if m != nil {
		return m.Address
	}
	return ""
}

func (m *Deployable_Deployment) GetResourceUri() []string {
	if m != nil {
		return m.ResourceUri
	}
	return nil
}

func (m *Deployable_Deployment) GetPlatform() Deployable_Deployment_Platform {
	if m != nil {
		return m.Platform
	}
	return Deployable_Deployment_PLATFORM_UNSPECIFIED
}

// DockerImage holds types defining base image notes
// and derived image occurrences.
type DockerImage struct {
}

func (m *DockerImage) Reset()                    { *m = DockerImage{} }
func (m *DockerImage) String() string            { return proto.CompactTextString(m) }
func (*DockerImage) ProtoMessage()               {}
func (*DockerImage) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{33} }

// Layer holds metadata specific to a layer of a Docker image.
type DockerImage_Layer struct {
	// The recovered Dockerfile directive used to construct this layer.
	Directive DockerImage_Layer_Directive `protobuf:"varint,1,opt,name=directive,enum=grafeas.v1alpha1.api.DockerImage_Layer_Directive" json:"directive,omitempty"`
	// The recovered arguments to the Dockerfile directive.
	Arguments string `protobuf:"bytes,2,opt,name=arguments" json:"arguments,omitempty"`
}

func (m *DockerImage_Layer) Reset()                    { *m = DockerImage_Layer{} }
func (m *DockerImage_Layer) String() string            { return proto.CompactTextString(m) }
func (*DockerImage_Layer) ProtoMessage()               {}
func (*DockerImage_Layer) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{33, 0} }

func (m *DockerImage_Layer) GetDirective() DockerImage_Layer_Directive {
	if m != nil {
		return m.Directive
	}
	return DockerImage_Layer_DIRECTIVE_UNSPECIFIED
}

func (m *DockerImage_Layer) GetArguments() string {
	if m != nil {
		return m.Arguments
	}
	return ""
}

// A set of properties that uniquely identify a given Docker image.
type DockerImage_Fingerprint struct {
	// The layer-id of the final layer in the Docker image's v1
	// representation.
	// This field can be used as a filter in list requests.
	V1Name string `protobuf:"bytes,1,opt,name=v1_name,json=v1Name" json:"v1_name,omitempty"`
	// The ordered list of v2 blobs that represent a given image.
	V2Blob []string `protobuf:"bytes,2,rep,name=v2_blob,json=v2Blob" json:"v2_blob,omitempty"`
	// Output only. The name of the image's v2 blobs computed via:
	//   [bottom] := v2_blob[bottom]
	//   [N] := sha256(v2_blob[N] + " " + v2_name[N+1])
	// Only the name of the final blob is kept.
	// This field can be used as a filter in list requests.
	V2Name string `protobuf:"bytes,3,opt,name=v2_name,json=v2Name" json:"v2_name,omitempty"`
}

func (m *DockerImage_Fingerprint) Reset()                    { *m = DockerImage_Fingerprint{} }
func (m *DockerImage_Fingerprint) String() string            { return proto.CompactTextString(m) }
func (*DockerImage_Fingerprint) ProtoMessage()               {}
func (*DockerImage_Fingerprint) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{33, 1} }

func (m *DockerImage_Fingerprint) GetV1Name() string {
	if m != nil {
		return m.V1Name
	}
	return ""
}

func (m *DockerImage_Fingerprint) GetV2Blob() []string {
	if m != nil {
		return m.V2Blob
	}
	return nil
}

func (m *DockerImage_Fingerprint) GetV2Name() string {
	if m != nil {
		return m.V2Name
	}
	return ""
}

// Basis describes the base image portion (Note) of the DockerImage
// relationship.  Linked occurrences are derived from this or an
// equivalent image via:
//   FROM <Basis.resource_url>
// Or an equivalent reference, e.g. a tag of the resource_url.
type DockerImage_Basis struct {
	// The resource_url for the resource representing the basis of
	// associated occurrence images.
	ResourceUrl string `protobuf:"bytes,1,opt,name=resource_url,json=resourceUrl" json:"resource_url,omitempty"`
	// The fingerprint of the base image
	Fingerprint *DockerImage_Fingerprint `protobuf:"bytes,2,opt,name=fingerprint" json:"fingerprint,omitempty"`
}

func (m *DockerImage_Basis) Reset()                    { *m = DockerImage_Basis{} }
func (m *DockerImage_Basis) String() string            { return proto.CompactTextString(m) }
func (*DockerImage_Basis) ProtoMessage()               {}
func (*DockerImage_Basis) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{33, 2} }

func (m *DockerImage_Basis) GetResourceUrl() string {
	if m != nil {
		return m.ResourceUrl
	}
	return ""
}

func (m *DockerImage_Basis) GetFingerprint() *DockerImage_Fingerprint {
	if m != nil {
		return m.Fingerprint
	}
	return nil
}

// Derived describes the derived image portion (Occurrence) of the
// DockerImage relationship.  This image would be produced from a Dockerfile
// with FROM <DockerImage.Basis in attached Note>.
type DockerImage_Derived struct {
	// The fingerprint of the derived image
	Fingerprint *DockerImage_Fingerprint `protobuf:"bytes,1,opt,name=fingerprint" json:"fingerprint,omitempty"`
	// Output only. The number of layers by which this image differs from
	// the associated image basis.
	Distance uint32 `protobuf:"varint,2,opt,name=distance" json:"distance,omitempty"`
	// This contains layer-specific metadata, if populated it
	// has length "distance" and is ordered with [distance] being the
	// layer immediately following the base image and [1]
	// being the final layer.
	LayerInfo []*DockerImage_Layer `protobuf:"bytes,3,rep,name=layer_info,json=layerInfo" json:"layer_info,omitempty"`
	// Output only.This contains the base image url for the derived image
	// Occurrence
	BaseResourceUrl string `protobuf:"bytes,4,opt,name=base_resource_url,json=baseResourceUrl" json:"base_resource_url,omitempty"`
}

func (m *DockerImage_Derived) Reset()                    { *m = DockerImage_Derived{} }
func (m *DockerImage_Derived) String() string            { return proto.CompactTextString(m) }
func (*DockerImage_Derived) ProtoMessage()               {}
func (*DockerImage_Derived) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{33, 3} }

func (m *DockerImage_Derived) GetFingerprint() *DockerImage_Fingerprint {
	if m != nil {
		return m.Fingerprint
	}
	return nil
}

func (m *DockerImage_Derived) GetDistance() uint32 {
	if m != nil {
		return m.Distance
	}
	return 0
}

func (m *DockerImage_Derived) GetLayerInfo() []*DockerImage_Layer {
	if m != nil {
		return m.LayerInfo
	}
	return nil
}

func (m *DockerImage_Derived) GetBaseResourceUrl() string {
	if m != nil {
		return m.BaseResourceUrl
	}
	return ""
}

// A note that indicates a type of analysis a provider would perform. This note
// exists in a provider's project. A `Discovery` occurrence is created in a
// consumer's project at the start of analysis. The occurrence's operation will
// indicate the status of the analysis. Absence of an occurrence linked to this
// note for a resource indicates that analysis hasn't started.
type Discovery struct {
	// The kind of analysis that is handled by this discovery.
	AnalysisKind Note_Kind `protobuf:"varint,1,opt,name=analysis_kind,json=analysisKind,enum=grafeas.v1alpha1.api.Note_Kind" json:"analysis_kind,omitempty"`
}

func (m *Discovery) Reset()                    { *m = Discovery{} }
func (m *Discovery) String() string            { return proto.CompactTextString(m) }
func (*Discovery) ProtoMessage()               {}
func (*Discovery) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{34} }

func (m *Discovery) GetAnalysisKind() Note_Kind {
	if m != nil {
		return m.AnalysisKind
	}
	return Note_KIND_UNSPECIFIED
}

// Provides information about the scan status of a discovered resource.
type Discovery_Discovered struct {
	// Output only. An operation that indicates the status of the current scan.
	Operation *google_longrunning.Operation `protobuf:"bytes,1,opt,name=operation" json:"operation,omitempty"`
}

func (m *Discovery_Discovered) Reset()                    { *m = Discovery_Discovered{} }
func (m *Discovery_Discovered) String() string            { return proto.CompactTextString(m) }
func (*Discovery_Discovered) ProtoMessage()               {}
func (*Discovery_Discovered) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{34, 0} }

func (m *Discovery_Discovered) GetOperation() *google_longrunning.Operation {
	if m != nil {
		return m.Operation
	}
	return nil
}

// Container message for hashes of byte content of files, used in Source
// messages to verify integrity of source input to the build.
type FileHashes struct {
	// Collection of file hashes.
	FileHash []*Hash `protobuf:"bytes,1,rep,name=file_hash,json=fileHash" json:"file_hash,omitempty"`
}

func (m *FileHashes) Reset()                    { *m = FileHashes{} }
func (m *FileHashes) String() string            { return proto.CompactTextString(m) }
func (*FileHashes) ProtoMessage()               {}
func (*FileHashes) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{35} }

func (m *FileHashes) GetFileHash() []*Hash {
	if m != nil {
		return m.FileHash
	}
	return nil
}

// Container message for hash values.
type Hash struct {
	// The type of hash that was performed.
	Type Hash_HashType `protobuf:"varint,1,opt,name=type,enum=grafeas.v1alpha1.api.Hash_HashType" json:"type,omitempty"`
	// The hash value.
	Value []byte `protobuf:"bytes,2,opt,name=value,proto3" json:"value,omitempty"`
}

func (m *Hash) Reset()                    { *m = Hash{} }
func (m *Hash) String() string            { return proto.CompactTextString(m) }
func (*Hash) ProtoMessage()               {}
func (*Hash) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{36} }

func (m *Hash) GetType() Hash_HashType {
	if m != nil {
		return m.Type
	}
	return Hash_NONE
}

func (m *Hash) GetValue() []byte {
	if m != nil {
		return m.Value
	}
	return nil
}

// Provides a detailed description of a `Note`.
type Note struct {
	// The name of the note in the form
	// "providers/{provider_id}/notes/{NOTE_ID}"
	Name string `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	// A one sentence description of this `Note`.
	ShortDescription string `protobuf:"bytes,3,opt,name=short_description,json=shortDescription" json:"short_description,omitempty"`
	// A detailed description of this `Note`.
	LongDescription string `protobuf:"bytes,4,opt,name=long_description,json=longDescription" json:"long_description,omitempty"`
	// Output only. This explicitly denotes which kind of note is specified. This
	// field can be used as a filter in list requests.
	Kind Note_Kind `protobuf:"varint,9,opt,name=kind,enum=grafeas.v1alpha1.api.Note_Kind" json:"kind,omitempty"`
	// The type of note.
	//
	// Types that are valid to be assigned to NoteType:
	//	*Note_VulnerabilityType
	//	*Note_AttestationType
	//	*Note_BuildType
	//	*Note_BaseImage
	//	*Note_Package
	//	*Note_Deployable
	//	*Note_Discovery
	NoteType isNote_NoteType `protobuf_oneof:"note_type"`
	// URLs associated with this note
	RelatedUrl []*Note_RelatedUrl `protobuf:"bytes,7,rep,name=related_url,json=relatedUrl" json:"related_url,omitempty"`
	// Time of expiration for this note, null if note does not expire.
	ExpirationTime *google_protobuf3.Timestamp `protobuf:"bytes,10,opt,name=expiration_time,json=expirationTime" json:"expiration_time,omitempty"`
	// Output only. The time this note was created. This field can be used as a
	// filter in list requests.
	CreateTime *google_protobuf3.Timestamp `protobuf:"bytes,11,opt,name=create_time,json=createTime" json:"create_time,omitempty"`
	// Output only. The time this note was last updated. This field can be used as
	// a filter in list requests.
	UpdateTime *google_protobuf3.Timestamp `protobuf:"bytes,12,opt,name=update_time,json=updateTime" json:"update_time,omitempty"`
}

func (m *Note) Reset()                    { *m = Note{} }
func (m *Note) String() string            { return proto.CompactTextString(m) }
func (*Note) ProtoMessage()               {}
func (*Note) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{37} }

type isNote_NoteType interface {
	isNote_NoteType()
}

type Note_VulnerabilityType struct {
	VulnerabilityType *VulnerabilityType `protobuf:"bytes,6,opt,name=vulnerability_type,json=vulnerabilityType,oneof"`
}
type Note_AttestationType struct {
	AttestationType *AttestationAuthority `protobuf:"bytes,19,opt,name=attestation_type,json=attestationType,oneof"`
}
type Note_BuildType struct {
	BuildType *BuildType `protobuf:"bytes,8,opt,name=build_type,json=buildType,oneof"`
}
type Note_BaseImage struct {
	BaseImage *DockerImage_Basis `protobuf:"bytes,13,opt,name=base_image,json=baseImage,oneof"`
}
type Note_Package struct {
	Package *PackageManager_Package `protobuf:"bytes,14,opt,name=package,oneof"`
}
type Note_Deployable struct {
	Deployable *Deployable `protobuf:"bytes,17,opt,name=deployable,oneof"`
}
type Note_Discovery struct {
	Discovery *Discovery `protobuf:"bytes,18,opt,name=discovery,oneof"`
}

func (*Note_VulnerabilityType) isNote_NoteType() {}
func (*Note_AttestationType) isNote_NoteType()   {}
func (*Note_BuildType) isNote_NoteType()         {}
func (*Note_BaseImage) isNote_NoteType()         {}
func (*Note_Package) isNote_NoteType()           {}
func (*Note_Deployable) isNote_NoteType()        {}
func (*Note_Discovery) isNote_NoteType()         {}

func (m *Note) GetNoteType() isNote_NoteType {
	if m != nil {
		return m.NoteType
	}
	return nil
}

func (m *Note) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Note) GetShortDescription() string {
	if m != nil {
		return m.ShortDescription
	}
	return ""
}

func (m *Note) GetLongDescription() string {
	if m != nil {
		return m.LongDescription
	}
	return ""
}

func (m *Note) GetKind() Note_Kind {
	if m != nil {
		return m.Kind
	}
	return Note_KIND_UNSPECIFIED
}

func (m *Note) GetVulnerabilityType() *VulnerabilityType {
	if x, ok := m.GetNoteType().(*Note_VulnerabilityType); ok {
		return x.VulnerabilityType
	}
	return nil
}

func (m *Note) GetAttestationType() *AttestationAuthority {
	if x, ok := m.GetNoteType().(*Note_AttestationType); ok {
		return x.AttestationType
	}
	return nil
}

func (m *Note) GetBuildType() *BuildType {
	if x, ok := m.GetNoteType().(*Note_BuildType); ok {
		return x.BuildType
	}
	return nil
}

func (m *Note) GetBaseImage() *DockerImage_Basis {
	if x, ok := m.GetNoteType().(*Note_BaseImage); ok {
		return x.BaseImage
	}
	return nil
}

func (m *Note) GetPackage() *PackageManager_Package {
	if x, ok := m.GetNoteType().(*Note_Package); ok {
		return x.Package
	}
	return nil
}

func (m *Note) GetDeployable() *Deployable {
	if x, ok := m.GetNoteType().(*Note_Deployable); ok {
		return x.Deployable
	}
	return nil
}

func (m *Note) GetDiscovery() *Discovery {
	if x, ok := m.GetNoteType().(*Note_Discovery); ok {
		return x.Discovery
	}
	return nil
}

func (m *Note) GetRelatedUrl() []*Note_RelatedUrl {
	if m != nil {
		return m.RelatedUrl
	}
	return nil
}

func (m *Note) GetExpirationTime() *google_protobuf3.Timestamp {
	if m != nil {
		return m.ExpirationTime
	}
	return nil
}

func (m *Note) GetCreateTime() *google_protobuf3.Timestamp {
	if m != nil {
		return m.CreateTime
	}
	return nil
}

func (m *Note) GetUpdateTime() *google_protobuf3.Timestamp {
	if m != nil {
		return m.UpdateTime
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*Note) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _Note_OneofMarshaler, _Note_OneofUnmarshaler, _Note_OneofSizer, []interface{}{
		(*Note_VulnerabilityType)(nil),
		(*Note_AttestationType)(nil),
		(*Note_BuildType)(nil),
		(*Note_BaseImage)(nil),
		(*Note_Package)(nil),
		(*Note_Deployable)(nil),
		(*Note_Discovery)(nil),
	}
}

func _Note_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*Note)
	// note_type
	switch x := m.NoteType.(type) {
	case *Note_VulnerabilityType:
		b.EncodeVarint(6<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.VulnerabilityType); err != nil {
			return err
		}
	case *Note_AttestationType:
		b.EncodeVarint(19<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.AttestationType); err != nil {
			return err
		}
	case *Note_BuildType:
		b.EncodeVarint(8<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.BuildType); err != nil {
			return err
		}
	case *Note_BaseImage:
		b.EncodeVarint(13<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.BaseImage); err != nil {
			return err
		}
	case *Note_Package:
		b.EncodeVarint(14<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Package); err != nil {
			return err
		}
	case *Note_Deployable:
		b.EncodeVarint(17<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Deployable); err != nil {
			return err
		}
	case *Note_Discovery:
		b.EncodeVarint(18<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Discovery); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("Note.NoteType has unexpected type %T", x)
	}
	return nil
}

func _Note_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*Note)
	switch tag {
	case 6: // note_type.vulnerability_type
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(VulnerabilityType)
		err := b.DecodeMessage(msg)
		m.NoteType = &Note_VulnerabilityType{msg}
		return true, err
	case 19: // note_type.attestation_type
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(AttestationAuthority)
		err := b.DecodeMessage(msg)
		m.NoteType = &Note_AttestationType{msg}
		return true, err
	case 8: // note_type.build_type
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(BuildType)
		err := b.DecodeMessage(msg)
		m.NoteType = &Note_BuildType{msg}
		return true, err
	case 13: // note_type.base_image
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(DockerImage_Basis)
		err := b.DecodeMessage(msg)
		m.NoteType = &Note_BaseImage{msg}
		return true, err
	case 14: // note_type.package
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(PackageManager_Package)
		err := b.DecodeMessage(msg)
		m.NoteType = &Note_Package{msg}
		return true, err
	case 17: // note_type.deployable
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Deployable)
		err := b.DecodeMessage(msg)
		m.NoteType = &Note_Deployable{msg}
		return true, err
	case 18: // note_type.discovery
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Discovery)
		err := b.DecodeMessage(msg)
		m.NoteType = &Note_Discovery{msg}
		return true, err
	default:
		return false, nil
	}
}

func _Note_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*Note)
	// note_type
	switch x := m.NoteType.(type) {
	case *Note_VulnerabilityType:
		s := proto.Size(x.VulnerabilityType)
		n += proto.SizeVarint(6<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Note_AttestationType:
		s := proto.Size(x.AttestationType)
		n += proto.SizeVarint(19<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Note_BuildType:
		s := proto.Size(x.BuildType)
		n += proto.SizeVarint(8<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Note_BaseImage:
		s := proto.Size(x.BaseImage)
		n += proto.SizeVarint(13<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Note_Package:
		s := proto.Size(x.Package)
		n += proto.SizeVarint(14<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Note_Deployable:
		s := proto.Size(x.Deployable)
		n += proto.SizeVarint(17<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Note_Discovery:
		s := proto.Size(x.Discovery)
		n += proto.SizeVarint(18<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// Metadata for any related URL information
type Note_RelatedUrl struct {
	// Specific URL to associate with the note
	Url string `protobuf:"bytes,1,opt,name=url" json:"url,omitempty"`
	// Label to describe usage of the URL
	Label string `protobuf:"bytes,2,opt,name=label" json:"label,omitempty"`
}

func (m *Note_RelatedUrl) Reset()                    { *m = Note_RelatedUrl{} }
func (m *Note_RelatedUrl) String() string            { return proto.CompactTextString(m) }
func (*Note_RelatedUrl) ProtoMessage()               {}
func (*Note_RelatedUrl) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{37, 0} }

func (m *Note_RelatedUrl) GetUrl() string {
	if m != nil {
		return m.Url
	}
	return ""
}

func (m *Note_RelatedUrl) GetLabel() string {
	if m != nil {
		return m.Label
	}
	return ""
}

// `Occurrence` includes information about analysis occurrences for an image.
type Occurrence struct {
	// Output only. The name of the `Occurrence` in the form
	// "projects/{project_id}/occurrences/{OCCURRENCE_ID}"
	Name string `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	// The unique URL of the image or the container for which the `Occurrence`
	// applies. For example, https://gcr.io/project/image@sha256:foo This field
	// can be used as a filter in list requests.
	ResourceUrl string `protobuf:"bytes,2,opt,name=resource_url,json=resourceUrl" json:"resource_url,omitempty"`
	// An analysis note associated with this image, in the form
	// "providers/{provider_id}/notes/{NOTE_ID}"
	// This field can be used as a filter in list requests.
	NoteName string `protobuf:"bytes,3,opt,name=note_name,json=noteName" json:"note_name,omitempty"`
	// Output only. This explicitly denotes which of the `Occurrence` details are
	// specified. This field can be used as a filter in list requests.
	Kind Note_Kind `protobuf:"varint,6,opt,name=kind,enum=grafeas.v1alpha1.api.Note_Kind" json:"kind,omitempty"`
	// Describes the details of the vulnerability `Note` found in this resource.
	//
	// Types that are valid to be assigned to Details:
	//	*Occurrence_VulnerabilityDetails
	//	*Occurrence_AttestationDetails
	//	*Occurrence_BuildDetails
	//	*Occurrence_DerivedImage
	//	*Occurrence_Installation
	//	*Occurrence_Deployment
	//	*Occurrence_Discovered
	Details isOccurrence_Details `protobuf_oneof:"details"`
	// A description of actions that can be taken to remedy the `Note`
	Remediation string `protobuf:"bytes,5,opt,name=remediation" json:"remediation,omitempty"`
	// Output only. The time this `Occurrence` was created.
	CreateTime *google_protobuf3.Timestamp `protobuf:"bytes,9,opt,name=create_time,json=createTime" json:"create_time,omitempty"`
	// Output only. The time this `Occurrence` was last updated.
	UpdateTime *google_protobuf3.Timestamp `protobuf:"bytes,10,opt,name=update_time,json=updateTime" json:"update_time,omitempty"`
}

func (m *Occurrence) Reset()                    { *m = Occurrence{} }
func (m *Occurrence) String() string            { return proto.CompactTextString(m) }
func (*Occurrence) ProtoMessage()               {}
func (*Occurrence) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{38} }

type isOccurrence_Details interface {
	isOccurrence_Details()
}

type Occurrence_VulnerabilityDetails struct {
	VulnerabilityDetails *VulnerabilityType_VulnerabilityDetails `protobuf:"bytes,8,opt,name=vulnerability_details,json=vulnerabilityDetails,oneof"`
}
type Occurrence_AttestationDetails struct {
	AttestationDetails *AttestationAuthority_Attestation `protobuf:"bytes,16,opt,name=attestation_details,json=attestationDetails,oneof"`
}
type Occurrence_BuildDetails struct {
	BuildDetails *BuildDetails `protobuf:"bytes,7,opt,name=build_details,json=buildDetails,oneof"`
}
type Occurrence_DerivedImage struct {
	DerivedImage *DockerImage_Derived `protobuf:"bytes,11,opt,name=derived_image,json=derivedImage,oneof"`
}
type Occurrence_Installation struct {
	Installation *PackageManager_Installation `protobuf:"bytes,12,opt,name=installation,oneof"`
}
type Occurrence_Deployment struct {
	Deployment *Deployable_Deployment `protobuf:"bytes,14,opt,name=deployment,oneof"`
}
type Occurrence_Discovered struct {
	Discovered *Discovery_Discovered `protobuf:"bytes,15,opt,name=discovered,oneof"`
}

func (*Occurrence_VulnerabilityDetails) isOccurrence_Details() {}
func (*Occurrence_AttestationDetails) isOccurrence_Details()   {}
func (*Occurrence_BuildDetails) isOccurrence_Details()         {}
func (*Occurrence_DerivedImage) isOccurrence_Details()         {}
func (*Occurrence_Installation) isOccurrence_Details()         {}
func (*Occurrence_Deployment) isOccurrence_Details()           {}
func (*Occurrence_Discovered) isOccurrence_Details()           {}

func (m *Occurrence) GetDetails() isOccurrence_Details {
	if m != nil {
		return m.Details
	}
	return nil
}

func (m *Occurrence) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Occurrence) GetResourceUrl() string {
	if m != nil {
		return m.ResourceUrl
	}
	return ""
}

func (m *Occurrence) GetNoteName() string {
	if m != nil {
		return m.NoteName
	}
	return ""
}

func (m *Occurrence) GetKind() Note_Kind {
	if m != nil {
		return m.Kind
	}
	return Note_KIND_UNSPECIFIED
}

func (m *Occurrence) GetVulnerabilityDetails() *VulnerabilityType_VulnerabilityDetails {
	if x, ok := m.GetDetails().(*Occurrence_VulnerabilityDetails); ok {
		return x.VulnerabilityDetails
	}
	return nil
}

func (m *Occurrence) GetAttestationDetails() *AttestationAuthority_Attestation {
	if x, ok := m.GetDetails().(*Occurrence_AttestationDetails); ok {
		return x.AttestationDetails
	}
	return nil
}

func (m *Occurrence) GetBuildDetails() *BuildDetails {
	if x, ok := m.GetDetails().(*Occurrence_BuildDetails); ok {
		return x.BuildDetails
	}
	return nil
}

func (m *Occurrence) GetDerivedImage() *DockerImage_Derived {
	if x, ok := m.GetDetails().(*Occurrence_DerivedImage); ok {
		return x.DerivedImage
	}
	return nil
}

func (m *Occurrence) GetInstallation() *PackageManager_Installation {
	if x, ok := m.GetDetails().(*Occurrence_Installation); ok {
		return x.Installation
	}
	return nil
}

func (m *Occurrence) GetDeployment() *Deployable_Deployment {
	if x, ok := m.GetDetails().(*Occurrence_Deployment); ok {
		return x.Deployment
	}
	return nil
}

func (m *Occurrence) GetDiscovered() *Discovery_Discovered {
	if x, ok := m.GetDetails().(*Occurrence_Discovered); ok {
		return x.Discovered
	}
	return nil
}

func (m *Occurrence) GetRemediation() string {
	if m != nil {
		return m.Remediation
	}
	return ""
}

func (m *Occurrence) GetCreateTime() *google_protobuf3.Timestamp {
	if m != nil {
		return m.CreateTime
	}
	return nil
}

func (m *Occurrence) GetUpdateTime() *google_protobuf3.Timestamp {
	if m != nil {
		return m.UpdateTime
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*Occurrence) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _Occurrence_OneofMarshaler, _Occurrence_OneofUnmarshaler, _Occurrence_OneofSizer, []interface{}{
		(*Occurrence_VulnerabilityDetails)(nil),
		(*Occurrence_AttestationDetails)(nil),
		(*Occurrence_BuildDetails)(nil),
		(*Occurrence_DerivedImage)(nil),
		(*Occurrence_Installation)(nil),
		(*Occurrence_Deployment)(nil),
		(*Occurrence_Discovered)(nil),
	}
}

func _Occurrence_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*Occurrence)
	// details
	switch x := m.Details.(type) {
	case *Occurrence_VulnerabilityDetails:
		b.EncodeVarint(8<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.VulnerabilityDetails); err != nil {
			return err
		}
	case *Occurrence_AttestationDetails:
		b.EncodeVarint(16<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.AttestationDetails); err != nil {
			return err
		}
	case *Occurrence_BuildDetails:
		b.EncodeVarint(7<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.BuildDetails); err != nil {
			return err
		}
	case *Occurrence_DerivedImage:
		b.EncodeVarint(11<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.DerivedImage); err != nil {
			return err
		}
	case *Occurrence_Installation:
		b.EncodeVarint(12<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Installation); err != nil {
			return err
		}
	case *Occurrence_Deployment:
		b.EncodeVarint(14<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Deployment); err != nil {
			return err
		}
	case *Occurrence_Discovered:
		b.EncodeVarint(15<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Discovered); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("Occurrence.Details has unexpected type %T", x)
	}
	return nil
}

func _Occurrence_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*Occurrence)
	switch tag {
	case 8: // details.vulnerability_details
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(VulnerabilityType_VulnerabilityDetails)
		err := b.DecodeMessage(msg)
		m.Details = &Occurrence_VulnerabilityDetails{msg}
		return true, err
	case 16: // details.attestation_details
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(AttestationAuthority_Attestation)
		err := b.DecodeMessage(msg)
		m.Details = &Occurrence_AttestationDetails{msg}
		return true, err
	case 7: // details.build_details
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(BuildDetails)
		err := b.DecodeMessage(msg)
		m.Details = &Occurrence_BuildDetails{msg}
		return true, err
	case 11: // details.derived_image
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(DockerImage_Derived)
		err := b.DecodeMessage(msg)
		m.Details = &Occurrence_DerivedImage{msg}
		return true, err
	case 12: // details.installation
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(PackageManager_Installation)
		err := b.DecodeMessage(msg)
		m.Details = &Occurrence_Installation{msg}
		return true, err
	case 14: // details.deployment
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Deployable_Deployment)
		err := b.DecodeMessage(msg)
		m.Details = &Occurrence_Deployment{msg}
		return true, err
	case 15: // details.discovered
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Discovery_Discovered)
		err := b.DecodeMessage(msg)
		m.Details = &Occurrence_Discovered{msg}
		return true, err
	default:
		return false, nil
	}
}

func _Occurrence_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*Occurrence)
	// details
	switch x := m.Details.(type) {
	case *Occurrence_VulnerabilityDetails:
		s := proto.Size(x.VulnerabilityDetails)
		n += proto.SizeVarint(8<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Occurrence_AttestationDetails:
		s := proto.Size(x.AttestationDetails)
		n += proto.SizeVarint(16<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Occurrence_BuildDetails:
		s := proto.Size(x.BuildDetails)
		n += proto.SizeVarint(7<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Occurrence_DerivedImage:
		s := proto.Size(x.DerivedImage)
		n += proto.SizeVarint(11<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Occurrence_Installation:
		s := proto.Size(x.Installation)
		n += proto.SizeVarint(12<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Occurrence_Deployment:
		s := proto.Size(x.Deployment)
		n += proto.SizeVarint(14<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Occurrence_Discovered:
		s := proto.Size(x.Discovered)
		n += proto.SizeVarint(15<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// PackageManager provides metadata about available / installed packages.
type PackageManager struct {
}

func (m *PackageManager) Reset()                    { *m = PackageManager{} }
func (m *PackageManager) String() string            { return proto.CompactTextString(m) }
func (*PackageManager) ProtoMessage()               {}
func (*PackageManager) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{39} }

// This represents a particular channel of distribution for a given package.
// e.g. Debian's jessie-backports dpkg mirror
type PackageManager_Distribution struct {
	// The cpe_uri in [cpe format](https://cpe.mitre.org/specification/)
	// denoting the package manager version distributing a package.
	CpeUri string `protobuf:"bytes,1,opt,name=cpe_uri,json=cpeUri" json:"cpe_uri,omitempty"`
	// The CPU architecture for which packages in this distribution
	// channel were built
	Architecture PackageManager_Architecture `protobuf:"varint,2,opt,name=architecture,enum=grafeas.v1alpha1.api.PackageManager_Architecture" json:"architecture,omitempty"`
	// The latest available version of this package in
	// this distribution channel.
	LatestVersion *VulnerabilityType_Version `protobuf:"bytes,3,opt,name=latest_version,json=latestVersion" json:"latest_version,omitempty"`
	// A freeform string denoting the maintainer of this package.
	Maintainer string `protobuf:"bytes,4,opt,name=maintainer" json:"maintainer,omitempty"`
	// The distribution channel-specific homepage for this package.
	Url string `protobuf:"bytes,6,opt,name=url" json:"url,omitempty"`
	// The distribution channel-specific description of this package.
	Description string `protobuf:"bytes,7,opt,name=description" json:"description,omitempty"`
}

func (m *PackageManager_Distribution) Reset()                    { *m = PackageManager_Distribution{} }
func (m *PackageManager_Distribution) String() string            { return proto.CompactTextString(m) }
func (*PackageManager_Distribution) ProtoMessage()               {}
func (*PackageManager_Distribution) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{39, 0} }

func (m *PackageManager_Distribution) GetCpeUri() string {
	if m != nil {
		return m.CpeUri
	}
	return ""
}

func (m *PackageManager_Distribution) GetArchitecture() PackageManager_Architecture {
	if m != nil {
		return m.Architecture
	}
	return PackageManager_ARCHITECTURE_UNSPECIFIED
}

func (m *PackageManager_Distribution) GetLatestVersion() *VulnerabilityType_Version {
	if m != nil {
		return m.LatestVersion
	}
	return nil
}

func (m *PackageManager_Distribution) GetMaintainer() string {
	if m != nil {
		return m.Maintainer
	}
	return ""
}

func (m *PackageManager_Distribution) GetUrl() string {
	if m != nil {
		return m.Url
	}
	return ""
}

func (m *PackageManager_Distribution) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

// An occurrence of a particular package installation found within a
// system's filesystem.
// e.g. glibc was found in /var/lib/dpkg/status
type PackageManager_Location struct {
	// The cpe_uri in [cpe format](https://cpe.mitre.org/specification/)
	// denoting the package manager version distributing a package.
	CpeUri string `protobuf:"bytes,1,opt,name=cpe_uri,json=cpeUri" json:"cpe_uri,omitempty"`
	// The version installed at this location.
	Version *VulnerabilityType_Version `protobuf:"bytes,2,opt,name=version" json:"version,omitempty"`
	// The path from which we gathered that this package/version is installed.
	Path string `protobuf:"bytes,3,opt,name=path" json:"path,omitempty"`
}

func (m *PackageManager_Location) Reset()                    { *m = PackageManager_Location{} }
func (m *PackageManager_Location) String() string            { return proto.CompactTextString(m) }
func (*PackageManager_Location) ProtoMessage()               {}
func (*PackageManager_Location) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{39, 1} }

func (m *PackageManager_Location) GetCpeUri() string {
	if m != nil {
		return m.CpeUri
	}
	return ""
}

func (m *PackageManager_Location) GetVersion() *VulnerabilityType_Version {
	if m != nil {
		return m.Version
	}
	return nil
}

func (m *PackageManager_Location) GetPath() string {
	if m != nil {
		return m.Path
	}
	return ""
}

// This represents a particular package that is distributed over
// various channels.
// e.g. glibc (aka libc6) is distributed by many, at various versions.
type PackageManager_Package struct {
	// The name of the package.
	Name string `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	// The various channels by which a package is distributed.
	Distribution []*PackageManager_Distribution `protobuf:"bytes,10,rep,name=distribution" json:"distribution,omitempty"`
}

func (m *PackageManager_Package) Reset()                    { *m = PackageManager_Package{} }
func (m *PackageManager_Package) String() string            { return proto.CompactTextString(m) }
func (*PackageManager_Package) ProtoMessage()               {}
func (*PackageManager_Package) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{39, 2} }

func (m *PackageManager_Package) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *PackageManager_Package) GetDistribution() []*PackageManager_Distribution {
	if m != nil {
		return m.Distribution
	}
	return nil
}

// This represents how a particular software package may be installed on
// a system.
type PackageManager_Installation struct {
	// Output only. The name of the installed package.
	Name string `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	// All of the places within the filesystem versions of this package
	// have been found.
	Location []*PackageManager_Location `protobuf:"bytes,2,rep,name=location" json:"location,omitempty"`
}

func (m *PackageManager_Installation) Reset()                    { *m = PackageManager_Installation{} }
func (m *PackageManager_Installation) String() string            { return proto.CompactTextString(m) }
func (*PackageManager_Installation) ProtoMessage()               {}
func (*PackageManager_Installation) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{39, 3} }

func (m *PackageManager_Installation) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *PackageManager_Installation) GetLocation() []*PackageManager_Location {
	if m != nil {
		return m.Location
	}
	return nil
}

// An attestation wrapper with a PGP-compatible signature.
// This message only supports ATTACHED signatures, where the payload that is
// signed is included alongside the signature itself in the same file.
type PgpSignedAttestation struct {
	// The raw content of the signature, as output by gpg or equivalent.  Since
	// this message only supports attached signatures, the payload that was signed
	// must be attached. While the signature format supported is dependent on the
	// verification implementation, currently only ASCII-armored (`--armor` to
	// gpg), non-clearsigned (`--sign` rather than `--clearsign` to gpg) are
	// supported.
	// Concretely, `gpg --sign --armor --output=signature.gpg payload.json` will
	// create the signature content expected in this field in `signature.gpg` for
	// the `payload.json` attestation payload.
	Signature string `protobuf:"bytes,1,opt,name=signature" json:"signature,omitempty"`
	// Type (e.g. schema) of the attestation payload that was signed.
	// The verifier must ensure that the provided type is one that the verifier
	// supports, and that the attestation payload is a valid instantiation of that
	// type (e.g. by validating a JSON schema).
	ContentType PgpSignedAttestation_ContentType `protobuf:"varint,3,opt,name=content_type,json=contentType,enum=grafeas.v1alpha1.api.PgpSignedAttestation_ContentType" json:"content_type,omitempty"`
	// This field is used by verifiers to select the public key used to validate
	// the signature.  Note that the policy of the verifier ultimately determines
	// which public keys verify a signature based on the context of the
	// verification.  There is no guarantee validation will succeed if the
	// verifier has no key matching this ID, even if it has a key under a
	// different ID that would verify the signature. Note that this ID should also
	// be present in the signature content above, but that is not expected to be
	// used by the verifier.
	//
	// Types that are valid to be assigned to KeyId:
	//	*PgpSignedAttestation_PgpKeyId
	KeyId isPgpSignedAttestation_KeyId `protobuf_oneof:"key_id"`
}

func (m *PgpSignedAttestation) Reset()                    { *m = PgpSignedAttestation{} }
func (m *PgpSignedAttestation) String() string            { return proto.CompactTextString(m) }
func (*PgpSignedAttestation) ProtoMessage()               {}
func (*PgpSignedAttestation) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{40} }

type isPgpSignedAttestation_KeyId interface {
	isPgpSignedAttestation_KeyId()
}

type PgpSignedAttestation_PgpKeyId struct {
	PgpKeyId string `protobuf:"bytes,2,opt,name=pgp_key_id,json=pgpKeyId,oneof"`
}

func (*PgpSignedAttestation_PgpKeyId) isPgpSignedAttestation_KeyId() {}

func (m *PgpSignedAttestation) GetKeyId() isPgpSignedAttestation_KeyId {
	if m != nil {
		return m.KeyId
	}
	return nil
}

func (m *PgpSignedAttestation) GetSignature() string {
	if m != nil {
		return m.Signature
	}
	return ""
}

func (m *PgpSignedAttestation) GetContentType() PgpSignedAttestation_ContentType {
	if m != nil {
		return m.ContentType
	}
	return PgpSignedAttestation_CONTENT_TYPE_UNSPECIFIED
}

func (m *PgpSignedAttestation) GetPgpKeyId() string {
	if x, ok := m.GetKeyId().(*PgpSignedAttestation_PgpKeyId); ok {
		return x.PgpKeyId
	}
	return ""
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*PgpSignedAttestation) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _PgpSignedAttestation_OneofMarshaler, _PgpSignedAttestation_OneofUnmarshaler, _PgpSignedAttestation_OneofSizer, []interface{}{
		(*PgpSignedAttestation_PgpKeyId)(nil),
	}
}

func _PgpSignedAttestation_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*PgpSignedAttestation)
	// key_id
	switch x := m.KeyId.(type) {
	case *PgpSignedAttestation_PgpKeyId:
		b.EncodeVarint(2<<3 | proto.WireBytes)
		b.EncodeStringBytes(x.PgpKeyId)
	case nil:
	default:
		return fmt.Errorf("PgpSignedAttestation.KeyId has unexpected type %T", x)
	}
	return nil
}

func _PgpSignedAttestation_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*PgpSignedAttestation)
	switch tag {
	case 2: // key_id.pgp_key_id
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeStringBytes()
		m.KeyId = &PgpSignedAttestation_PgpKeyId{x}
		return true, err
	default:
		return false, nil
	}
}

func _PgpSignedAttestation_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*PgpSignedAttestation)
	// key_id
	switch x := m.KeyId.(type) {
	case *PgpSignedAttestation_PgpKeyId:
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(len(x.PgpKeyId)))
		n += len(x.PgpKeyId)
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// Source describes the location of the source used for the build.
type Source struct {
	// Source location information.
	//
	// Types that are valid to be assigned to Source:
	//	*Source_StorageSource
	//	*Source_RepoSource
	Source isSource_Source `protobuf_oneof:"source"`
	// If provided, the input binary artifacts for the build came from this
	// location.
	ArtifactStorageSource *StorageSource `protobuf:"bytes,4,opt,name=artifact_storage_source,json=artifactStorageSource" json:"artifact_storage_source,omitempty"`
	// Hash(es) of the build source, which can be used to verify that the original
	// source integrity was maintained in the build.
	//
	// The keys to this map are file paths used as build source and the values
	// contain the hash values for those files.
	//
	// If the build source came in a single package such as a gzipped tarfile
	// (.tar.gz), the FileHash will be for the single path to that file.
	FileHashes map[string]*FileHashes `protobuf:"bytes,3,rep,name=file_hashes,json=fileHashes" json:"file_hashes,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	// If provided, the source code used for the build came from this location.
	Context *SourceContext `protobuf:"bytes,7,opt,name=context" json:"context,omitempty"`
	// If provided, some of the source code used for the build may be found in
	// these locations, in the case where the source repository had multiple
	// remotes or submodules. This list will not include the context specified in
	// the context field.
	AdditionalContexts []*SourceContext `protobuf:"bytes,8,rep,name=additional_contexts,json=additionalContexts" json:"additional_contexts,omitempty"`
}

func (m *Source) Reset()                    { *m = Source{} }
func (m *Source) String() string            { return proto.CompactTextString(m) }
func (*Source) ProtoMessage()               {}
func (*Source) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{41} }

type isSource_Source interface {
	isSource_Source()
}

type Source_StorageSource struct {
	StorageSource *StorageSource `protobuf:"bytes,1,opt,name=storage_source,json=storageSource,oneof"`
}
type Source_RepoSource struct {
	RepoSource *RepoSource `protobuf:"bytes,2,opt,name=repo_source,json=repoSource,oneof"`
}

func (*Source_StorageSource) isSource_Source() {}
func (*Source_RepoSource) isSource_Source()    {}

func (m *Source) GetSource() isSource_Source {
	if m != nil {
		return m.Source
	}
	return nil
}

func (m *Source) GetStorageSource() *StorageSource {
	if x, ok := m.GetSource().(*Source_StorageSource); ok {
		return x.StorageSource
	}
	return nil
}

func (m *Source) GetRepoSource() *RepoSource {
	if x, ok := m.GetSource().(*Source_RepoSource); ok {
		return x.RepoSource
	}
	return nil
}

func (m *Source) GetArtifactStorageSource() *StorageSource {
	if m != nil {
		return m.ArtifactStorageSource
	}
	return nil
}

func (m *Source) GetFileHashes() map[string]*FileHashes {
	if m != nil {
		return m.FileHashes
	}
	return nil
}

func (m *Source) GetContext() *SourceContext {
	if m != nil {
		return m.Context
	}
	return nil
}

func (m *Source) GetAdditionalContexts() []*SourceContext {
	if m != nil {
		return m.AdditionalContexts
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*Source) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _Source_OneofMarshaler, _Source_OneofUnmarshaler, _Source_OneofSizer, []interface{}{
		(*Source_StorageSource)(nil),
		(*Source_RepoSource)(nil),
	}
}

func _Source_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*Source)
	// source
	switch x := m.Source.(type) {
	case *Source_StorageSource:
		b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.StorageSource); err != nil {
			return err
		}
	case *Source_RepoSource:
		b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.RepoSource); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("Source.Source has unexpected type %T", x)
	}
	return nil
}

func _Source_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*Source)
	switch tag {
	case 1: // source.storage_source
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(StorageSource)
		err := b.DecodeMessage(msg)
		m.Source = &Source_StorageSource{msg}
		return true, err
	case 2: // source.repo_source
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(RepoSource)
		err := b.DecodeMessage(msg)
		m.Source = &Source_RepoSource{msg}
		return true, err
	default:
		return false, nil
	}
}

func _Source_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*Source)
	// source
	switch x := m.Source.(type) {
	case *Source_StorageSource:
		s := proto.Size(x.StorageSource)
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Source_RepoSource:
		s := proto.Size(x.RepoSource)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// RepoSource describes the location of the source in a Google Cloud Source
// Repository.
type RepoSource struct {
	// ID of the project that owns the repo.
	ProjectId string `protobuf:"bytes,1,opt,name=project_id,json=projectId" json:"project_id,omitempty"`
	// Name of the repo.
	RepoName string `protobuf:"bytes,2,opt,name=repo_name,json=repoName" json:"repo_name,omitempty"`
	// A revision within the source repository must be specified in
	// one of these ways.
	//
	// Types that are valid to be assigned to Revision:
	//	*RepoSource_BranchName
	//	*RepoSource_TagName
	//	*RepoSource_CommitSha
	Revision isRepoSource_Revision `protobuf_oneof:"revision"`
}

func (m *RepoSource) Reset()                    { *m = RepoSource{} }
func (m *RepoSource) String() string            { return proto.CompactTextString(m) }
func (*RepoSource) ProtoMessage()               {}
func (*RepoSource) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{42} }

type isRepoSource_Revision interface {
	isRepoSource_Revision()
}

type RepoSource_BranchName struct {
	BranchName string `protobuf:"bytes,3,opt,name=branch_name,json=branchName,oneof"`
}
type RepoSource_TagName struct {
	TagName string `protobuf:"bytes,4,opt,name=tag_name,json=tagName,oneof"`
}
type RepoSource_CommitSha struct {
	CommitSha string `protobuf:"bytes,5,opt,name=commit_sha,json=commitSha,oneof"`
}

func (*RepoSource_BranchName) isRepoSource_Revision() {}
func (*RepoSource_TagName) isRepoSource_Revision()    {}
func (*RepoSource_CommitSha) isRepoSource_Revision()  {}

func (m *RepoSource) GetRevision() isRepoSource_Revision {
	if m != nil {
		return m.Revision
	}
	return nil
}

func (m *RepoSource) GetProjectId() string {
	if m != nil {
		return m.ProjectId
	}
	return ""
}

func (m *RepoSource) GetRepoName() string {
	if m != nil {
		return m.RepoName
	}
	return ""
}

func (m *RepoSource) GetBranchName() string {
	if x, ok := m.GetRevision().(*RepoSource_BranchName); ok {
		return x.BranchName
	}
	return ""
}

func (m *RepoSource) GetTagName() string {
	if x, ok := m.GetRevision().(*RepoSource_TagName); ok {
		return x.TagName
	}
	return ""
}

func (m *RepoSource) GetCommitSha() string {
	if x, ok := m.GetRevision().(*RepoSource_CommitSha); ok {
		return x.CommitSha
	}
	return ""
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*RepoSource) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _RepoSource_OneofMarshaler, _RepoSource_OneofUnmarshaler, _RepoSource_OneofSizer, []interface{}{
		(*RepoSource_BranchName)(nil),
		(*RepoSource_TagName)(nil),
		(*RepoSource_CommitSha)(nil),
	}
}

func _RepoSource_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*RepoSource)
	// revision
	switch x := m.Revision.(type) {
	case *RepoSource_BranchName:
		b.EncodeVarint(3<<3 | proto.WireBytes)
		b.EncodeStringBytes(x.BranchName)
	case *RepoSource_TagName:
		b.EncodeVarint(4<<3 | proto.WireBytes)
		b.EncodeStringBytes(x.TagName)
	case *RepoSource_CommitSha:
		b.EncodeVarint(5<<3 | proto.WireBytes)
		b.EncodeStringBytes(x.CommitSha)
	case nil:
	default:
		return fmt.Errorf("RepoSource.Revision has unexpected type %T", x)
	}
	return nil
}

func _RepoSource_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*RepoSource)
	switch tag {
	case 3: // revision.branch_name
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeStringBytes()
		m.Revision = &RepoSource_BranchName{x}
		return true, err
	case 4: // revision.tag_name
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeStringBytes()
		m.Revision = &RepoSource_TagName{x}
		return true, err
	case 5: // revision.commit_sha
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeStringBytes()
		m.Revision = &RepoSource_CommitSha{x}
		return true, err
	default:
		return false, nil
	}
}

func _RepoSource_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*RepoSource)
	// revision
	switch x := m.Revision.(type) {
	case *RepoSource_BranchName:
		n += proto.SizeVarint(3<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(len(x.BranchName)))
		n += len(x.BranchName)
	case *RepoSource_TagName:
		n += proto.SizeVarint(4<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(len(x.TagName)))
		n += len(x.TagName)
	case *RepoSource_CommitSha:
		n += proto.SizeVarint(5<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(len(x.CommitSha)))
		n += len(x.CommitSha)
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// StorageSource describes the location of the source in an archive file in
// Google Cloud Storage.
type StorageSource struct {
	// Google Cloud Storage bucket containing source (see [Bucket Name
	// Requirements]
	// (https://cloud.google.com/storage/docs/bucket-naming#requirements)).
	Bucket string `protobuf:"bytes,1,opt,name=bucket" json:"bucket,omitempty"`
	// Google Cloud Storage object containing source.
	Object string `protobuf:"bytes,2,opt,name=object" json:"object,omitempty"`
	// Google Cloud Storage generation for the object.
	Generation int64 `protobuf:"varint,3,opt,name=generation" json:"generation,omitempty"`
}

func (m *StorageSource) Reset()                    { *m = StorageSource{} }
func (m *StorageSource) String() string            { return proto.CompactTextString(m) }
func (*StorageSource) ProtoMessage()               {}
func (*StorageSource) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{43} }

func (m *StorageSource) GetBucket() string {
	if m != nil {
		return m.Bucket
	}
	return ""
}

func (m *StorageSource) GetObject() string {
	if m != nil {
		return m.Object
	}
	return ""
}

func (m *StorageSource) GetGeneration() int64 {
	if m != nil {
		return m.Generation
	}
	return 0
}

// VulnerabilityType provides metadata about a security vulnerability.
type VulnerabilityType struct {
	// The CVSS score for this Vulnerability.
	CvssScore float32 `protobuf:"fixed32,2,opt,name=cvss_score,json=cvssScore" json:"cvss_score,omitempty"`
	// Note provider assigned impact of the vulnerability
	Severity VulnerabilityType_Severity `protobuf:"varint,3,opt,name=severity,enum=grafeas.v1alpha1.api.VulnerabilityType_Severity" json:"severity,omitempty"`
	// All information about the package to specifically identify this
	// vulnerability. One entry per (version range and cpe_uri) the
	// package vulnerability has manifested in.
	Details []*VulnerabilityType_Detail `protobuf:"bytes,4,rep,name=details" json:"details,omitempty"`
}

func (m *VulnerabilityType) Reset()                    { *m = VulnerabilityType{} }
func (m *VulnerabilityType) String() string            { return proto.CompactTextString(m) }
func (*VulnerabilityType) ProtoMessage()               {}
func (*VulnerabilityType) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{44} }

func (m *VulnerabilityType) GetCvssScore() float32 {
	if m != nil {
		return m.CvssScore
	}
	return 0
}

func (m *VulnerabilityType) GetSeverity() VulnerabilityType_Severity {
	if m != nil {
		return m.Severity
	}
	return VulnerabilityType_SEVERITY_UNSPECIFIED
}

func (m *VulnerabilityType) GetDetails() []*VulnerabilityType_Detail {
	if m != nil {
		return m.Details
	}
	return nil
}

// Version contains structured information about the version of the package.
// For a discussion of this in Debian/Ubuntu:
// http://serverfault.com/questions/604541/debian-packages-version-convention
// For a discussion of this in Redhat/Fedora/Centos:
// http://blog.jasonantman.com/2014/07/how-yum-and-rpm-compare-versions/
type VulnerabilityType_Version struct {
	// Used to correct mistakes in the version numbering scheme.
	Epoch int32 `protobuf:"varint,1,opt,name=epoch" json:"epoch,omitempty"`
	// The main part of the version name.
	Name string `protobuf:"bytes,2,opt,name=name" json:"name,omitempty"`
	// The iteration of the package build from the above version.
	Revision string `protobuf:"bytes,3,opt,name=revision" json:"revision,omitempty"`
	// Distinguish between sentinel MIN/MAX versions and normal versions.
	// If kind is not NORMAL, then the other fields are ignored.
	Kind VulnerabilityType_Version_VersionKind `protobuf:"varint,5,opt,name=kind,enum=grafeas.v1alpha1.api.VulnerabilityType_Version_VersionKind" json:"kind,omitempty"`
}

func (m *VulnerabilityType_Version) Reset()                    { *m = VulnerabilityType_Version{} }
func (m *VulnerabilityType_Version) String() string            { return proto.CompactTextString(m) }
func (*VulnerabilityType_Version) ProtoMessage()               {}
func (*VulnerabilityType_Version) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{44, 0} }

func (m *VulnerabilityType_Version) GetEpoch() int32 {
	if m != nil {
		return m.Epoch
	}
	return 0
}

func (m *VulnerabilityType_Version) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *VulnerabilityType_Version) GetRevision() string {
	if m != nil {
		return m.Revision
	}
	return ""
}

func (m *VulnerabilityType_Version) GetKind() VulnerabilityType_Version_VersionKind {
	if m != nil {
		return m.Kind
	}
	return VulnerabilityType_Version_NORMAL
}

// Identifies all occurrences of this vulnerability in the package for a
// specific distro/location
// For example: glibc in cpe:/o:debian:debian_linux:8 for versions 2.1 - 2.2
type VulnerabilityType_Detail struct {
	// The cpe_uri in [cpe format] (https://cpe.mitre.org/specification/) in
	// which the vulnerability manifests.  Examples include distro or storage
	// location for vulnerable jar.
	// This field can be used as a filter in list requests.
	CpeUri string `protobuf:"bytes,1,opt,name=cpe_uri,json=cpeUri" json:"cpe_uri,omitempty"`
	// The name of the package where the vulnerability was found.
	// This field can be used as a filter in list requests.
	Package string `protobuf:"bytes,8,opt,name=package" json:"package,omitempty"`
	// The min version of the package in which the vulnerability exists.
	MinAffectedVersion *VulnerabilityType_Version `protobuf:"bytes,6,opt,name=min_affected_version,json=minAffectedVersion" json:"min_affected_version,omitempty"`
	// The max version of the package in which the vulnerability exists.
	// This field can be used as a filter in list requests.
	MaxAffectedVersion *VulnerabilityType_Version `protobuf:"bytes,7,opt,name=max_affected_version,json=maxAffectedVersion" json:"max_affected_version,omitempty"`
	// The severity (eg: distro assigned severity) for this vulnerability.
	SeverityName string `protobuf:"bytes,4,opt,name=severity_name,json=severityName" json:"severity_name,omitempty"`
	// A vendor-specific description of this note.
	Description string `protobuf:"bytes,9,opt,name=description" json:"description,omitempty"`
	// The fix for this specific package version.
	FixedLocation *VulnerabilityType_VulnerabilityLocation `protobuf:"bytes,5,opt,name=fixed_location,json=fixedLocation" json:"fixed_location,omitempty"`
	// The type of package; whether native or non native(ruby gems,
	// node.js packages etc)
	PackageType string `protobuf:"bytes,10,opt,name=package_type,json=packageType" json:"package_type,omitempty"`
}

func (m *VulnerabilityType_Detail) Reset()                    { *m = VulnerabilityType_Detail{} }
func (m *VulnerabilityType_Detail) String() string            { return proto.CompactTextString(m) }
func (*VulnerabilityType_Detail) ProtoMessage()               {}
func (*VulnerabilityType_Detail) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{44, 1} }

func (m *VulnerabilityType_Detail) GetCpeUri() string {
	if m != nil {
		return m.CpeUri
	}
	return ""
}

func (m *VulnerabilityType_Detail) GetPackage() string {
	if m != nil {
		return m.Package
	}
	return ""
}

func (m *VulnerabilityType_Detail) GetMinAffectedVersion() *VulnerabilityType_Version {
	if m != nil {
		return m.MinAffectedVersion
	}
	return nil
}

func (m *VulnerabilityType_Detail) GetMaxAffectedVersion() *VulnerabilityType_Version {
	if m != nil {
		return m.MaxAffectedVersion
	}
	return nil
}

func (m *VulnerabilityType_Detail) GetSeverityName() string {
	if m != nil {
		return m.SeverityName
	}
	return ""
}

func (m *VulnerabilityType_Detail) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *VulnerabilityType_Detail) GetFixedLocation() *VulnerabilityType_VulnerabilityLocation {
	if m != nil {
		return m.FixedLocation
	}
	return nil
}

func (m *VulnerabilityType_Detail) GetPackageType() string {
	if m != nil {
		return m.PackageType
	}
	return ""
}

// Used by Occurrence to point to where the vulnerability exists and how
// to fix it.
type VulnerabilityType_VulnerabilityDetails struct {
	// The type of package; whether native or non native(ruby gems,
	// node.js packages etc)
	Type string `protobuf:"bytes,3,opt,name=type" json:"type,omitempty"`
	// Output only. The note provider assigned Severity of the vulnerability.
	Severity VulnerabilityType_Severity `protobuf:"varint,4,opt,name=severity,enum=grafeas.v1alpha1.api.VulnerabilityType_Severity" json:"severity,omitempty"`
	// Output only. The CVSS score of this vulnerability. CVSS score is on a
	// scale of 0-10 where 0 indicates low severity and 10 indicates high
	// severity.
	CvssScore float32 `protobuf:"fixed32,5,opt,name=cvss_score,json=cvssScore" json:"cvss_score,omitempty"`
	// The set of affected locations and their fixes (if available) within
	// the associated resource.
	PackageIssue []*VulnerabilityType_PackageIssue `protobuf:"bytes,6,rep,name=package_issue,json=packageIssue" json:"package_issue,omitempty"`
}

func (m *VulnerabilityType_VulnerabilityDetails) Reset() {
	*m = VulnerabilityType_VulnerabilityDetails{}
}
func (m *VulnerabilityType_VulnerabilityDetails) String() string { return proto.CompactTextString(m) }
func (*VulnerabilityType_VulnerabilityDetails) ProtoMessage()    {}
func (*VulnerabilityType_VulnerabilityDetails) Descriptor() ([]byte, []int) {
	return fileDescriptor0, []int{44, 2}
}

func (m *VulnerabilityType_VulnerabilityDetails) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

func (m *VulnerabilityType_VulnerabilityDetails) GetSeverity() VulnerabilityType_Severity {
	if m != nil {
		return m.Severity
	}
	return VulnerabilityType_SEVERITY_UNSPECIFIED
}

func (m *VulnerabilityType_VulnerabilityDetails) GetCvssScore() float32 {
	if m != nil {
		return m.CvssScore
	}
	return 0
}

func (m *VulnerabilityType_VulnerabilityDetails) GetPackageIssue() []*VulnerabilityType_PackageIssue {
	if m != nil {
		return m.PackageIssue
	}
	return nil
}

// This message wraps a location affected by a vulnerability and its
// associated fix (if one is available).
type VulnerabilityType_PackageIssue struct {
	// The location of the vulnerability.
	AffectedLocation *VulnerabilityType_VulnerabilityLocation `protobuf:"bytes,1,opt,name=affected_location,json=affectedLocation" json:"affected_location,omitempty"`
	// The location of the available fix for vulnerability.
	FixedLocation *VulnerabilityType_VulnerabilityLocation `protobuf:"bytes,2,opt,name=fixed_location,json=fixedLocation" json:"fixed_location,omitempty"`
	// The severity (eg: distro assigned severity) for this vulnerability.
	SeverityName string `protobuf:"bytes,3,opt,name=severity_name,json=severityName" json:"severity_name,omitempty"`
}

func (m *VulnerabilityType_PackageIssue) Reset()         { *m = VulnerabilityType_PackageIssue{} }
func (m *VulnerabilityType_PackageIssue) String() string { return proto.CompactTextString(m) }
func (*VulnerabilityType_PackageIssue) ProtoMessage()    {}
func (*VulnerabilityType_PackageIssue) Descriptor() ([]byte, []int) {
	return fileDescriptor0, []int{44, 3}
}

func (m *VulnerabilityType_PackageIssue) GetAffectedLocation() *VulnerabilityType_VulnerabilityLocation {
	if m != nil {
		return m.AffectedLocation
	}
	return nil
}

func (m *VulnerabilityType_PackageIssue) GetFixedLocation() *VulnerabilityType_VulnerabilityLocation {
	if m != nil {
		return m.FixedLocation
	}
	return nil
}

func (m *VulnerabilityType_PackageIssue) GetSeverityName() string {
	if m != nil {
		return m.SeverityName
	}
	return ""
}

// The location of the vulnerability
type VulnerabilityType_VulnerabilityLocation struct {
	// The cpe_uri in [cpe format] (https://cpe.mitre.org/specification/)
	// format. Examples include distro or storage location for vulnerable jar.
	// This field can be used as a filter in list requests.
	CpeUri string `protobuf:"bytes,1,opt,name=cpe_uri,json=cpeUri" json:"cpe_uri,omitempty"`
	// The package being described.
	Package string `protobuf:"bytes,2,opt,name=package" json:"package,omitempty"`
	// The version of the package being described.
	// This field can be used as a filter in list requests.
	Version *VulnerabilityType_Version `protobuf:"bytes,4,opt,name=version" json:"version,omitempty"`
}

func (m *VulnerabilityType_VulnerabilityLocation) Reset() {
	*m = VulnerabilityType_VulnerabilityLocation{}
}
func (m *VulnerabilityType_VulnerabilityLocation) String() string { return proto.CompactTextString(m) }
func (*VulnerabilityType_VulnerabilityLocation) ProtoMessage()    {}
func (*VulnerabilityType_VulnerabilityLocation) Descriptor() ([]byte, []int) {
	return fileDescriptor0, []int{44, 4}
}

func (m *VulnerabilityType_VulnerabilityLocation) GetCpeUri() string {
	if m != nil {
		return m.CpeUri
	}
	return ""
}

func (m *VulnerabilityType_VulnerabilityLocation) GetPackage() string {
	if m != nil {
		return m.Package
	}
	return ""
}

func (m *VulnerabilityType_VulnerabilityLocation) GetVersion() *VulnerabilityType_Version {
	if m != nil {
		return m.Version
	}
	return nil
}

// A SourceContext is a reference to a tree of files. A SourceContext together
// with a path point to a unique revision of a single file or directory.
type SourceContext struct {
	// A SourceContext can refer any one of the following types of repositories.
	//
	// Types that are valid to be assigned to Context:
	//	*SourceContext_CloudRepo
	//	*SourceContext_Gerrit
	//	*SourceContext_Git
	Context isSourceContext_Context `protobuf_oneof:"context"`
	// Labels with user defined metadata.
	Labels map[string]string `protobuf:"bytes,4,rep,name=labels" json:"labels,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
}

func (m *SourceContext) Reset()                    { *m = SourceContext{} }
func (m *SourceContext) String() string            { return proto.CompactTextString(m) }
func (*SourceContext) ProtoMessage()               {}
func (*SourceContext) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{45} }

type isSourceContext_Context interface {
	isSourceContext_Context()
}

type SourceContext_CloudRepo struct {
	CloudRepo *CloudRepoSourceContext `protobuf:"bytes,1,opt,name=cloud_repo,json=cloudRepo,oneof"`
}
type SourceContext_Gerrit struct {
	Gerrit *GerritSourceContext `protobuf:"bytes,2,opt,name=gerrit,oneof"`
}
type SourceContext_Git struct {
	Git *GitSourceContext `protobuf:"bytes,3,opt,name=git,oneof"`
}

func (*SourceContext_CloudRepo) isSourceContext_Context() {}
func (*SourceContext_Gerrit) isSourceContext_Context()    {}
func (*SourceContext_Git) isSourceContext_Context()       {}

func (m *SourceContext) GetContext() isSourceContext_Context {
	if m != nil {
		return m.Context
	}
	return nil
}

func (m *SourceContext) GetCloudRepo() *CloudRepoSourceContext {
	if x, ok := m.GetContext().(*SourceContext_CloudRepo); ok {
		return x.CloudRepo
	}
	return nil
}

func (m *SourceContext) GetGerrit() *GerritSourceContext {
	if x, ok := m.GetContext().(*SourceContext_Gerrit); ok {
		return x.Gerrit
	}
	return nil
}

func (m *SourceContext) GetGit() *GitSourceContext {
	if x, ok := m.GetContext().(*SourceContext_Git); ok {
		return x.Git
	}
	return nil
}

func (m *SourceContext) GetLabels() map[string]string {
	if m != nil {
		return m.Labels
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*SourceContext) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _SourceContext_OneofMarshaler, _SourceContext_OneofUnmarshaler, _SourceContext_OneofSizer, []interface{}{
		(*SourceContext_CloudRepo)(nil),
		(*SourceContext_Gerrit)(nil),
		(*SourceContext_Git)(nil),
	}
}

func _SourceContext_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*SourceContext)
	// context
	switch x := m.Context.(type) {
	case *SourceContext_CloudRepo:
		b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.CloudRepo); err != nil {
			return err
		}
	case *SourceContext_Gerrit:
		b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Gerrit); err != nil {
			return err
		}
	case *SourceContext_Git:
		b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Git); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("SourceContext.Context has unexpected type %T", x)
	}
	return nil
}

func _SourceContext_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*SourceContext)
	switch tag {
	case 1: // context.cloud_repo
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(CloudRepoSourceContext)
		err := b.DecodeMessage(msg)
		m.Context = &SourceContext_CloudRepo{msg}
		return true, err
	case 2: // context.gerrit
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(GerritSourceContext)
		err := b.DecodeMessage(msg)
		m.Context = &SourceContext_Gerrit{msg}
		return true, err
	case 3: // context.git
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(GitSourceContext)
		err := b.DecodeMessage(msg)
		m.Context = &SourceContext_Git{msg}
		return true, err
	default:
		return false, nil
	}
}

func _SourceContext_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*SourceContext)
	// context
	switch x := m.Context.(type) {
	case *SourceContext_CloudRepo:
		s := proto.Size(x.CloudRepo)
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *SourceContext_Gerrit:
		s := proto.Size(x.Gerrit)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *SourceContext_Git:
		s := proto.Size(x.Git)
		n += proto.SizeVarint(3<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// An alias to a repo revision.
type AliasContext struct {
	// The alias kind.
	Kind AliasContext_Kind `protobuf:"varint,1,opt,name=kind,enum=grafeas.v1alpha1.api.AliasContext_Kind" json:"kind,omitempty"`
	// The alias name.
	Name string `protobuf:"bytes,2,opt,name=name" json:"name,omitempty"`
}

func (m *AliasContext) Reset()                    { *m = AliasContext{} }
func (m *AliasContext) String() string            { return proto.CompactTextString(m) }
func (*AliasContext) ProtoMessage()               {}
func (*AliasContext) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{46} }

func (m *AliasContext) GetKind() AliasContext_Kind {
	if m != nil {
		return m.Kind
	}
	return AliasContext_KIND_UNSPECIFIED
}

func (m *AliasContext) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

// A CloudRepoSourceContext denotes a particular revision in a Google Cloud
// Source Repo.
type CloudRepoSourceContext struct {
	// The ID of the repo.
	RepoId *RepoId `protobuf:"bytes,1,opt,name=repo_id,json=repoId" json:"repo_id,omitempty"`
	// A revision in a Cloud Repo can be identified by either its revision ID or
	// its alias.
	//
	// Types that are valid to be assigned to Revision:
	//	*CloudRepoSourceContext_RevisionId
	//	*CloudRepoSourceContext_AliasContext
	Revision isCloudRepoSourceContext_Revision `protobuf_oneof:"revision"`
}

func (m *CloudRepoSourceContext) Reset()                    { *m = CloudRepoSourceContext{} }
func (m *CloudRepoSourceContext) String() string            { return proto.CompactTextString(m) }
func (*CloudRepoSourceContext) ProtoMessage()               {}
func (*CloudRepoSourceContext) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{47} }

type isCloudRepoSourceContext_Revision interface {
	isCloudRepoSourceContext_Revision()
}

type CloudRepoSourceContext_RevisionId struct {
	RevisionId string `protobuf:"bytes,2,opt,name=revision_id,json=revisionId,oneof"`
}
type CloudRepoSourceContext_AliasContext struct {
	AliasContext *AliasContext `protobuf:"bytes,3,opt,name=alias_context,json=aliasContext,oneof"`
}

func (*CloudRepoSourceContext_RevisionId) isCloudRepoSourceContext_Revision()   {}
func (*CloudRepoSourceContext_AliasContext) isCloudRepoSourceContext_Revision() {}

func (m *CloudRepoSourceContext) GetRevision() isCloudRepoSourceContext_Revision {
	if m != nil {
		return m.Revision
	}
	return nil
}

func (m *CloudRepoSourceContext) GetRepoId() *RepoId {
	if m != nil {
		return m.RepoId
	}
	return nil
}

func (m *CloudRepoSourceContext) GetRevisionId() string {
	if x, ok := m.GetRevision().(*CloudRepoSourceContext_RevisionId); ok {
		return x.RevisionId
	}
	return ""
}

func (m *CloudRepoSourceContext) GetAliasContext() *AliasContext {
	if x, ok := m.GetRevision().(*CloudRepoSourceContext_AliasContext); ok {
		return x.AliasContext
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*CloudRepoSourceContext) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _CloudRepoSourceContext_OneofMarshaler, _CloudRepoSourceContext_OneofUnmarshaler, _CloudRepoSourceContext_OneofSizer, []interface{}{
		(*CloudRepoSourceContext_RevisionId)(nil),
		(*CloudRepoSourceContext_AliasContext)(nil),
	}
}

func _CloudRepoSourceContext_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*CloudRepoSourceContext)
	// revision
	switch x := m.Revision.(type) {
	case *CloudRepoSourceContext_RevisionId:
		b.EncodeVarint(2<<3 | proto.WireBytes)
		b.EncodeStringBytes(x.RevisionId)
	case *CloudRepoSourceContext_AliasContext:
		b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.AliasContext); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("CloudRepoSourceContext.Revision has unexpected type %T", x)
	}
	return nil
}

func _CloudRepoSourceContext_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*CloudRepoSourceContext)
	switch tag {
	case 2: // revision.revision_id
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeStringBytes()
		m.Revision = &CloudRepoSourceContext_RevisionId{x}
		return true, err
	case 3: // revision.alias_context
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(AliasContext)
		err := b.DecodeMessage(msg)
		m.Revision = &CloudRepoSourceContext_AliasContext{msg}
		return true, err
	default:
		return false, nil
	}
}

func _CloudRepoSourceContext_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*CloudRepoSourceContext)
	// revision
	switch x := m.Revision.(type) {
	case *CloudRepoSourceContext_RevisionId:
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(len(x.RevisionId)))
		n += len(x.RevisionId)
	case *CloudRepoSourceContext_AliasContext:
		s := proto.Size(x.AliasContext)
		n += proto.SizeVarint(3<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// A SourceContext referring to a Gerrit project.
type GerritSourceContext struct {
	// The URI of a running Gerrit instance.
	HostUri string `protobuf:"bytes,1,opt,name=host_uri,json=hostUri" json:"host_uri,omitempty"`
	// The full project name within the host. Projects may be nested, so
	// "project/subproject" is a valid project name. The "repo name" is
	// the hostURI/project.
	GerritProject string `protobuf:"bytes,2,opt,name=gerrit_project,json=gerritProject" json:"gerrit_project,omitempty"`
	// A revision in a Gerrit project can be identified by either its revision ID
	// or its alias.
	//
	// Types that are valid to be assigned to Revision:
	//	*GerritSourceContext_RevisionId
	//	*GerritSourceContext_AliasContext
	Revision isGerritSourceContext_Revision `protobuf_oneof:"revision"`
}

func (m *GerritSourceContext) Reset()                    { *m = GerritSourceContext{} }
func (m *GerritSourceContext) String() string            { return proto.CompactTextString(m) }
func (*GerritSourceContext) ProtoMessage()               {}
func (*GerritSourceContext) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{48} }

type isGerritSourceContext_Revision interface {
	isGerritSourceContext_Revision()
}

type GerritSourceContext_RevisionId struct {
	RevisionId string `protobuf:"bytes,3,opt,name=revision_id,json=revisionId,oneof"`
}
type GerritSourceContext_AliasContext struct {
	AliasContext *AliasContext `protobuf:"bytes,4,opt,name=alias_context,json=aliasContext,oneof"`
}

func (*GerritSourceContext_RevisionId) isGerritSourceContext_Revision()   {}
func (*GerritSourceContext_AliasContext) isGerritSourceContext_Revision() {}

func (m *GerritSourceContext) GetRevision() isGerritSourceContext_Revision {
	if m != nil {
		return m.Revision
	}
	return nil
}

func (m *GerritSourceContext) GetHostUri() string {
	if m != nil {
		return m.HostUri
	}
	return ""
}

func (m *GerritSourceContext) GetGerritProject() string {
	if m != nil {
		return m.GerritProject
	}
	return ""
}

func (m *GerritSourceContext) GetRevisionId() string {
	if x, ok := m.GetRevision().(*GerritSourceContext_RevisionId); ok {
		return x.RevisionId
	}
	return ""
}

func (m *GerritSourceContext) GetAliasContext() *AliasContext {
	if x, ok := m.GetRevision().(*GerritSourceContext_AliasContext); ok {
		return x.AliasContext
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*GerritSourceContext) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _GerritSourceContext_OneofMarshaler, _GerritSourceContext_OneofUnmarshaler, _GerritSourceContext_OneofSizer, []interface{}{
		(*GerritSourceContext_RevisionId)(nil),
		(*GerritSourceContext_AliasContext)(nil),
	}
}

func _GerritSourceContext_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*GerritSourceContext)
	// revision
	switch x := m.Revision.(type) {
	case *GerritSourceContext_RevisionId:
		b.EncodeVarint(3<<3 | proto.WireBytes)
		b.EncodeStringBytes(x.RevisionId)
	case *GerritSourceContext_AliasContext:
		b.EncodeVarint(4<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.AliasContext); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("GerritSourceContext.Revision has unexpected type %T", x)
	}
	return nil
}

func _GerritSourceContext_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*GerritSourceContext)
	switch tag {
	case 3: // revision.revision_id
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeStringBytes()
		m.Revision = &GerritSourceContext_RevisionId{x}
		return true, err
	case 4: // revision.alias_context
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(AliasContext)
		err := b.DecodeMessage(msg)
		m.Revision = &GerritSourceContext_AliasContext{msg}
		return true, err
	default:
		return false, nil
	}
}

func _GerritSourceContext_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*GerritSourceContext)
	// revision
	switch x := m.Revision.(type) {
	case *GerritSourceContext_RevisionId:
		n += proto.SizeVarint(3<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(len(x.RevisionId)))
		n += len(x.RevisionId)
	case *GerritSourceContext_AliasContext:
		s := proto.Size(x.AliasContext)
		n += proto.SizeVarint(4<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// A GitSourceContext denotes a particular revision in a third party Git
// repository (e.g., GitHub).
type GitSourceContext struct {
	// Git repository URL.
	Url string `protobuf:"bytes,1,opt,name=url" json:"url,omitempty"`
	// Required.
	// Git commit hash.
	RevisionId string `protobuf:"bytes,2,opt,name=revision_id,json=revisionId" json:"revision_id,omitempty"`
}

func (m *GitSourceContext) Reset()                    { *m = GitSourceContext{} }
func (m *GitSourceContext) String() string            { return proto.CompactTextString(m) }
func (*GitSourceContext) ProtoMessage()               {}
func (*GitSourceContext) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{49} }

func (m *GitSourceContext) GetUrl() string {
	if m != nil {
		return m.Url
	}
	return ""
}

func (m *GitSourceContext) GetRevisionId() string {
	if m != nil {
		return m.RevisionId
	}
	return ""
}

// A unique identifier for a Cloud Repo.
type RepoId struct {
	// A cloud repo can be identified by either its project ID and repository name
	// combination, or its globally unique identifier.
	//
	// Types that are valid to be assigned to Id:
	//	*RepoId_ProjectRepoId
	//	*RepoId_Uid
	Id isRepoId_Id `protobuf_oneof:"id"`
}

func (m *RepoId) Reset()                    { *m = RepoId{} }
func (m *RepoId) String() string            { return proto.CompactTextString(m) }
func (*RepoId) ProtoMessage()               {}
func (*RepoId) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{50} }

type isRepoId_Id interface {
	isRepoId_Id()
}

type RepoId_ProjectRepoId struct {
	ProjectRepoId *ProjectRepoId `protobuf:"bytes,1,opt,name=project_repo_id,json=projectRepoId,oneof"`
}
type RepoId_Uid struct {
	Uid string `protobuf:"bytes,2,opt,name=uid,oneof"`
}

func (*RepoId_ProjectRepoId) isRepoId_Id() {}
func (*RepoId_Uid) isRepoId_Id()           {}

func (m *RepoId) GetId() isRepoId_Id {
	if m != nil {
		return m.Id
	}
	return nil
}

func (m *RepoId) GetProjectRepoId() *ProjectRepoId {
	if x, ok := m.GetId().(*RepoId_ProjectRepoId); ok {
		return x.ProjectRepoId
	}
	return nil
}

func (m *RepoId) GetUid() string {
	if x, ok := m.GetId().(*RepoId_Uid); ok {
		return x.Uid
	}
	return ""
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*RepoId) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _RepoId_OneofMarshaler, _RepoId_OneofUnmarshaler, _RepoId_OneofSizer, []interface{}{
		(*RepoId_ProjectRepoId)(nil),
		(*RepoId_Uid)(nil),
	}
}

func _RepoId_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*RepoId)
	// id
	switch x := m.Id.(type) {
	case *RepoId_ProjectRepoId:
		b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.ProjectRepoId); err != nil {
			return err
		}
	case *RepoId_Uid:
		b.EncodeVarint(2<<3 | proto.WireBytes)
		b.EncodeStringBytes(x.Uid)
	case nil:
	default:
		return fmt.Errorf("RepoId.Id has unexpected type %T", x)
	}
	return nil
}

func _RepoId_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*RepoId)
	switch tag {
	case 1: // id.project_repo_id
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ProjectRepoId)
		err := b.DecodeMessage(msg)
		m.Id = &RepoId_ProjectRepoId{msg}
		return true, err
	case 2: // id.uid
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeStringBytes()
		m.Id = &RepoId_Uid{x}
		return true, err
	default:
		return false, nil
	}
}

func _RepoId_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*RepoId)
	// id
	switch x := m.Id.(type) {
	case *RepoId_ProjectRepoId:
		s := proto.Size(x.ProjectRepoId)
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *RepoId_Uid:
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(len(x.Uid)))
		n += len(x.Uid)
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// Selects a repo using a Google Cloud Platform project ID (e.g.,
// winged-cargo-31) and a repo name within that project.
type ProjectRepoId struct {
	// The ID of the project.
	ProjectId string `protobuf:"bytes,1,opt,name=project_id,json=projectId" json:"project_id,omitempty"`
	// The name of the repo. Leave empty for the default repo.
	RepoName string `protobuf:"bytes,2,opt,name=repo_name,json=repoName" json:"repo_name,omitempty"`
}

func (m *ProjectRepoId) Reset()                    { *m = ProjectRepoId{} }
func (m *ProjectRepoId) String() string            { return proto.CompactTextString(m) }
func (*ProjectRepoId) ProtoMessage()               {}
func (*ProjectRepoId) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{51} }

func (m *ProjectRepoId) GetProjectId() string {
	if m != nil {
		return m.ProjectId
	}
	return ""
}

func (m *ProjectRepoId) GetRepoName() string {
	if m != nil {
		return m.RepoName
	}
	return ""
}

func init() {
	proto.RegisterType((*CreateProjectRequest)(nil), "grafeas.v1alpha1.api.CreateProjectRequest")
	proto.RegisterType((*GetProjectRequest)(nil), "grafeas.v1alpha1.api.GetProjectRequest")
	proto.RegisterType((*ListProjectsRequest)(nil), "grafeas.v1alpha1.api.ListProjectsRequest")
	proto.RegisterType((*DeleteProjectRequest)(nil), "grafeas.v1alpha1.api.DeleteProjectRequest")
	proto.RegisterType((*GetOccurrenceRequest)(nil), "grafeas.v1alpha1.api.GetOccurrenceRequest")
	proto.RegisterType((*ListOccurrencesRequest)(nil), "grafeas.v1alpha1.api.ListOccurrencesRequest")
	proto.RegisterType((*DeleteOccurrenceRequest)(nil), "grafeas.v1alpha1.api.DeleteOccurrenceRequest")
	proto.RegisterType((*CreateOccurrenceRequest)(nil), "grafeas.v1alpha1.api.CreateOccurrenceRequest")
	proto.RegisterType((*UpdateOccurrenceRequest)(nil), "grafeas.v1alpha1.api.UpdateOccurrenceRequest")
	proto.RegisterType((*GetNoteRequest)(nil), "grafeas.v1alpha1.api.GetNoteRequest")
	proto.RegisterType((*GetOccurrenceNoteRequest)(nil), "grafeas.v1alpha1.api.GetOccurrenceNoteRequest")
	proto.RegisterType((*ListNotesRequest)(nil), "grafeas.v1alpha1.api.ListNotesRequest")
	proto.RegisterType((*DeleteNoteRequest)(nil), "grafeas.v1alpha1.api.DeleteNoteRequest")
	proto.RegisterType((*CreateNoteRequest)(nil), "grafeas.v1alpha1.api.CreateNoteRequest")
	proto.RegisterType((*UpdateNoteRequest)(nil), "grafeas.v1alpha1.api.UpdateNoteRequest")
	proto.RegisterType((*ListNoteOccurrencesRequest)(nil), "grafeas.v1alpha1.api.ListNoteOccurrencesRequest")
	proto.RegisterType((*ListProjectsResponse)(nil), "grafeas.v1alpha1.api.ListProjectsResponse")
	proto.RegisterType((*ListNoteOccurrencesResponse)(nil), "grafeas.v1alpha1.api.ListNoteOccurrencesResponse")
	proto.RegisterType((*ListNotesResponse)(nil), "grafeas.v1alpha1.api.ListNotesResponse")
	proto.RegisterType((*ListOccurrencesResponse)(nil), "grafeas.v1alpha1.api.ListOccurrencesResponse")
	proto.RegisterType((*ListOperationsResponse)(nil), "grafeas.v1alpha1.api.ListOperationsResponse")
	proto.RegisterType((*UpdateOperationRequest)(nil), "grafeas.v1alpha1.api.UpdateOperationRequest")
	proto.RegisterType((*CreateOperationRequest)(nil), "grafeas.v1alpha1.api.CreateOperationRequest")
	proto.RegisterType((*Project)(nil), "grafeas.v1alpha1.api.Project")
	proto.RegisterType((*OperationMetadata)(nil), "grafeas.v1alpha1.api.OperationMetadata")
	proto.RegisterType((*Artifact)(nil), "grafeas.v1alpha1.api.Artifact")
	proto.RegisterType((*AttestationAuthority)(nil), "grafeas.v1alpha1.api.AttestationAuthority")
	proto.RegisterType((*AttestationAuthority_AttestationAuthorityHint)(nil), "grafeas.v1alpha1.api.AttestationAuthority.AttestationAuthorityHint")
	proto.RegisterType((*AttestationAuthority_Attestation)(nil), "grafeas.v1alpha1.api.AttestationAuthority.Attestation")
	proto.RegisterType((*BuildDetails)(nil), "grafeas.v1alpha1.api.BuildDetails")
	proto.RegisterType((*BuildProvenance)(nil), "grafeas.v1alpha1.api.BuildProvenance")
	proto.RegisterType((*BuildSignature)(nil), "grafeas.v1alpha1.api.BuildSignature")
	proto.RegisterType((*BuildType)(nil), "grafeas.v1alpha1.api.BuildType")
	proto.RegisterType((*Command)(nil), "grafeas.v1alpha1.api.Command")
	proto.RegisterType((*Deployable)(nil), "grafeas.v1alpha1.api.Deployable")
	proto.RegisterType((*Deployable_Deployment)(nil), "grafeas.v1alpha1.api.Deployable.Deployment")
	proto.RegisterType((*DockerImage)(nil), "grafeas.v1alpha1.api.DockerImage")
	proto.RegisterType((*DockerImage_Layer)(nil), "grafeas.v1alpha1.api.DockerImage.Layer")
	proto.RegisterType((*DockerImage_Fingerprint)(nil), "grafeas.v1alpha1.api.DockerImage.Fingerprint")
	proto.RegisterType((*DockerImage_Basis)(nil), "grafeas.v1alpha1.api.DockerImage.Basis")
	proto.RegisterType((*DockerImage_Derived)(nil), "grafeas.v1alpha1.api.DockerImage.Derived")
	proto.RegisterType((*Discovery)(nil), "grafeas.v1alpha1.api.Discovery")
	proto.RegisterType((*Discovery_Discovered)(nil), "grafeas.v1alpha1.api.Discovery.Discovered")
	proto.RegisterType((*FileHashes)(nil), "grafeas.v1alpha1.api.FileHashes")
	proto.RegisterType((*Hash)(nil), "grafeas.v1alpha1.api.Hash")
	proto.RegisterType((*Note)(nil), "grafeas.v1alpha1.api.Note")
	proto.RegisterType((*Note_RelatedUrl)(nil), "grafeas.v1alpha1.api.Note.RelatedUrl")
	proto.RegisterType((*Occurrence)(nil), "grafeas.v1alpha1.api.Occurrence")
	proto.RegisterType((*PackageManager)(nil), "grafeas.v1alpha1.api.PackageManager")
	proto.RegisterType((*PackageManager_Distribution)(nil), "grafeas.v1alpha1.api.PackageManager.Distribution")
	proto.RegisterType((*PackageManager_Location)(nil), "grafeas.v1alpha1.api.PackageManager.Location")
	proto.RegisterType((*PackageManager_Package)(nil), "grafeas.v1alpha1.api.PackageManager.Package")
	proto.RegisterType((*PackageManager_Installation)(nil), "grafeas.v1alpha1.api.PackageManager.Installation")
	proto.RegisterType((*PgpSignedAttestation)(nil), "grafeas.v1alpha1.api.PgpSignedAttestation")
	proto.RegisterType((*Source)(nil), "grafeas.v1alpha1.api.Source")
	proto.RegisterType((*RepoSource)(nil), "grafeas.v1alpha1.api.RepoSource")
	proto.RegisterType((*StorageSource)(nil), "grafeas.v1alpha1.api.StorageSource")
	proto.RegisterType((*VulnerabilityType)(nil), "grafeas.v1alpha1.api.VulnerabilityType")
	proto.RegisterType((*VulnerabilityType_Version)(nil), "grafeas.v1alpha1.api.VulnerabilityType.Version")
	proto.RegisterType((*VulnerabilityType_Detail)(nil), "grafeas.v1alpha1.api.VulnerabilityType.Detail")
	proto.RegisterType((*VulnerabilityType_VulnerabilityDetails)(nil), "grafeas.v1alpha1.api.VulnerabilityType.VulnerabilityDetails")
	proto.RegisterType((*VulnerabilityType_PackageIssue)(nil), "grafeas.v1alpha1.api.VulnerabilityType.PackageIssue")
	proto.RegisterType((*VulnerabilityType_VulnerabilityLocation)(nil), "grafeas.v1alpha1.api.VulnerabilityType.VulnerabilityLocation")
	proto.RegisterType((*SourceContext)(nil), "grafeas.v1alpha1.api.SourceContext")
	proto.RegisterType((*AliasContext)(nil), "grafeas.v1alpha1.api.AliasContext")
	proto.RegisterType((*CloudRepoSourceContext)(nil), "grafeas.v1alpha1.api.CloudRepoSourceContext")
	proto.RegisterType((*GerritSourceContext)(nil), "grafeas.v1alpha1.api.GerritSourceContext")
	proto.RegisterType((*GitSourceContext)(nil), "grafeas.v1alpha1.api.GitSourceContext")
	proto.RegisterType((*RepoId)(nil), "grafeas.v1alpha1.api.RepoId")
	proto.RegisterType((*ProjectRepoId)(nil), "grafeas.v1alpha1.api.ProjectRepoId")
	proto.RegisterEnum("grafeas.v1alpha1.api.BuildSignature_KeyType", BuildSignature_KeyType_name, BuildSignature_KeyType_value)
	proto.RegisterEnum("grafeas.v1alpha1.api.Deployable_Deployment_Platform", Deployable_Deployment_Platform_name, Deployable_Deployment_Platform_value)
	proto.RegisterEnum("grafeas.v1alpha1.api.DockerImage_Layer_Directive", DockerImage_Layer_Directive_name, DockerImage_Layer_Directive_value)
	proto.RegisterEnum("grafeas.v1alpha1.api.Hash_HashType", Hash_HashType_name, Hash_HashType_value)
	proto.RegisterEnum("grafeas.v1alpha1.api.Note_Kind", Note_Kind_name, Note_Kind_value)
	proto.RegisterEnum("grafeas.v1alpha1.api.PackageManager_Architecture", PackageManager_Architecture_name, PackageManager_Architecture_value)
	proto.RegisterEnum("grafeas.v1alpha1.api.PgpSignedAttestation_ContentType", PgpSignedAttestation_ContentType_name, PgpSignedAttestation_ContentType_value)
	proto.RegisterEnum("grafeas.v1alpha1.api.VulnerabilityType_Severity", VulnerabilityType_Severity_name, VulnerabilityType_Severity_value)
	proto.RegisterEnum("grafeas.v1alpha1.api.VulnerabilityType_Version_VersionKind", VulnerabilityType_Version_VersionKind_name, VulnerabilityType_Version_VersionKind_value)
	proto.RegisterEnum("grafeas.v1alpha1.api.AliasContext_Kind", AliasContext_Kind_name, AliasContext_Kind_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for Grafeas service

type GrafeasClient interface {
	// Returns the requested `Occurrence`.
	GetOccurrence(ctx context.Context, in *GetOccurrenceRequest, opts ...grpc.CallOption) (*Occurrence, error)
	// Lists active `Occurrences` for a given project matching the filters.
	ListOccurrences(ctx context.Context, in *ListOccurrencesRequest, opts ...grpc.CallOption) (*ListOccurrencesResponse, error)
	// Deletes the given `Occurrence` from the system. Use this when
	// an `Occurrence` is no longer applicable for the given resource.
	DeleteOccurrence(ctx context.Context, in *DeleteOccurrenceRequest, opts ...grpc.CallOption) (*google_protobuf.Empty, error)
	// Creates a new `Occurrence`. Use this method to create `Occurrences`
	// for a resource.
	CreateOccurrence(ctx context.Context, in *CreateOccurrenceRequest, opts ...grpc.CallOption) (*Occurrence, error)
	// Updates an existing occurrence.
	UpdateOccurrence(ctx context.Context, in *UpdateOccurrenceRequest, opts ...grpc.CallOption) (*Occurrence, error)
	// Gets the `Note` attached to the given `Occurrence`.
	GetOccurrenceNote(ctx context.Context, in *GetOccurrenceNoteRequest, opts ...grpc.CallOption) (*Note, error)
	// Creates a new `Operation`.
	CreateOperation(ctx context.Context, in *CreateOperationRequest, opts ...grpc.CallOption) (*google_longrunning.Operation, error)
	// Updates an existing operation returns an error if operation
	//  does not exist. The only valid operations are to update mark the done bit
	// change the result.
	UpdateOperation(ctx context.Context, in *UpdateOperationRequest, opts ...grpc.CallOption) (*google_longrunning.Operation, error)
	// Returns the requested `Note`.
	GetNote(ctx context.Context, in *GetNoteRequest, opts ...grpc.CallOption) (*Note, error)
	// Lists all `Notes` for a given project.
	ListNotes(ctx context.Context, in *ListNotesRequest, opts ...grpc.CallOption) (*ListNotesResponse, error)
	// Deletes the given `Note` from the system.
	DeleteNote(ctx context.Context, in *DeleteNoteRequest, opts ...grpc.CallOption) (*google_protobuf.Empty, error)
	// Creates a new `Note`.
	CreateNote(ctx context.Context, in *CreateNoteRequest, opts ...grpc.CallOption) (*Note, error)
	// Updates an existing `Note`.
	UpdateNote(ctx context.Context, in *UpdateNoteRequest, opts ...grpc.CallOption) (*Note, error)
	// Lists `Occurrences` referencing the specified `Note`. Use this method to
	// get all occurrences referencing your `Note` across all your customer
	// projects.
	ListNoteOccurrences(ctx context.Context, in *ListNoteOccurrencesRequest, opts ...grpc.CallOption) (*ListNoteOccurrencesResponse, error)
}

type grafeasClient struct {
	cc *grpc.ClientConn
}

func NewGrafeasClient(cc *grpc.ClientConn) GrafeasClient {
	return &grafeasClient{cc}
}

func (c *grafeasClient) GetOccurrence(ctx context.Context, in *GetOccurrenceRequest, opts ...grpc.CallOption) (*Occurrence, error) {
	out := new(Occurrence)
	err := grpc.Invoke(ctx, "/grafeas.v1alpha1.api.Grafeas/GetOccurrence", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *grafeasClient) ListOccurrences(ctx context.Context, in *ListOccurrencesRequest, opts ...grpc.CallOption) (*ListOccurrencesResponse, error) {
	out := new(ListOccurrencesResponse)
	err := grpc.Invoke(ctx, "/grafeas.v1alpha1.api.Grafeas/ListOccurrences", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *grafeasClient) DeleteOccurrence(ctx context.Context, in *DeleteOccurrenceRequest, opts ...grpc.CallOption) (*google_protobuf.Empty, error) {
	out := new(google_protobuf.Empty)
	err := grpc.Invoke(ctx, "/grafeas.v1alpha1.api.Grafeas/DeleteOccurrence", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *grafeasClient) CreateOccurrence(ctx context.Context, in *CreateOccurrenceRequest, opts ...grpc.CallOption) (*Occurrence, error) {
	out := new(Occurrence)
	err := grpc.Invoke(ctx, "/grafeas.v1alpha1.api.Grafeas/CreateOccurrence", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *grafeasClient) UpdateOccurrence(ctx context.Context, in *UpdateOccurrenceRequest, opts ...grpc.CallOption) (*Occurrence, error) {
	out := new(Occurrence)
	err := grpc.Invoke(ctx, "/grafeas.v1alpha1.api.Grafeas/UpdateOccurrence", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *grafeasClient) GetOccurrenceNote(ctx context.Context, in *GetOccurrenceNoteRequest, opts ...grpc.CallOption) (*Note, error) {
	out := new(Note)
	err := grpc.Invoke(ctx, "/grafeas.v1alpha1.api.Grafeas/GetOccurrenceNote", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *grafeasClient) CreateOperation(ctx context.Context, in *CreateOperationRequest, opts ...grpc.CallOption) (*google_longrunning.Operation, error) {
	out := new(google_longrunning.Operation)
	err := grpc.Invoke(ctx, "/grafeas.v1alpha1.api.Grafeas/CreateOperation", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *grafeasClient) UpdateOperation(ctx context.Context, in *UpdateOperationRequest, opts ...grpc.CallOption) (*google_longrunning.Operation, error) {
	out := new(google_longrunning.Operation)
	err := grpc.Invoke(ctx, "/grafeas.v1alpha1.api.Grafeas/UpdateOperation", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *grafeasClient) GetNote(ctx context.Context, in *GetNoteRequest, opts ...grpc.CallOption) (*Note, error) {
	out := new(Note)
	err := grpc.Invoke(ctx, "/grafeas.v1alpha1.api.Grafeas/GetNote", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *grafeasClient) ListNotes(ctx context.Context, in *ListNotesRequest, opts ...grpc.CallOption) (*ListNotesResponse, error) {
	out := new(ListNotesResponse)
	err := grpc.Invoke(ctx, "/grafeas.v1alpha1.api.Grafeas/ListNotes", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *grafeasClient) DeleteNote(ctx context.Context, in *DeleteNoteRequest, opts ...grpc.CallOption) (*google_protobuf.Empty, error) {
	out := new(google_protobuf.Empty)
	err := grpc.Invoke(ctx, "/grafeas.v1alpha1.api.Grafeas/DeleteNote", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *grafeasClient) CreateNote(ctx context.Context, in *CreateNoteRequest, opts ...grpc.CallOption) (*Note, error) {
	out := new(Note)
	err := grpc.Invoke(ctx, "/grafeas.v1alpha1.api.Grafeas/CreateNote", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *grafeasClient) UpdateNote(ctx context.Context, in *UpdateNoteRequest, opts ...grpc.CallOption) (*Note, error) {
	out := new(Note)
	err := grpc.Invoke(ctx, "/grafeas.v1alpha1.api.Grafeas/UpdateNote", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *grafeasClient) ListNoteOccurrences(ctx context.Context, in *ListNoteOccurrencesRequest, opts ...grpc.CallOption) (*ListNoteOccurrencesResponse, error) {
	out := new(ListNoteOccurrencesResponse)
	err := grpc.Invoke(ctx, "/grafeas.v1alpha1.api.Grafeas/ListNoteOccurrences", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for Grafeas service

type GrafeasServer interface {
	// Returns the requested `Occurrence`.
	GetOccurrence(context.Context, *GetOccurrenceRequest) (*Occurrence, error)
	// Lists active `Occurrences` for a given project matching the filters.
	ListOccurrences(context.Context, *ListOccurrencesRequest) (*ListOccurrencesResponse, error)
	// Deletes the given `Occurrence` from the system. Use this when
	// an `Occurrence` is no longer applicable for the given resource.
	DeleteOccurrence(context.Context, *DeleteOccurrenceRequest) (*google_protobuf.Empty, error)
	// Creates a new `Occurrence`. Use this method to create `Occurrences`
	// for a resource.
	CreateOccurrence(context.Context, *CreateOccurrenceRequest) (*Occurrence, error)
	// Updates an existing occurrence.
	UpdateOccurrence(context.Context, *UpdateOccurrenceRequest) (*Occurrence, error)
	// Gets the `Note` attached to the given `Occurrence`.
	GetOccurrenceNote(context.Context, *GetOccurrenceNoteRequest) (*Note, error)
	// Creates a new `Operation`.
	CreateOperation(context.Context, *CreateOperationRequest) (*google_longrunning.Operation, error)
	// Updates an existing operation returns an error if operation
	//  does not exist. The only valid operations are to update mark the done bit
	// change the result.
	UpdateOperation(context.Context, *UpdateOperationRequest) (*google_longrunning.Operation, error)
	// Returns the requested `Note`.
	GetNote(context.Context, *GetNoteRequest) (*Note, error)
	// Lists all `Notes` for a given project.
	ListNotes(context.Context, *ListNotesRequest) (*ListNotesResponse, error)
	// Deletes the given `Note` from the system.
	DeleteNote(context.Context, *DeleteNoteRequest) (*google_protobuf.Empty, error)
	// Creates a new `Note`.
	CreateNote(context.Context, *CreateNoteRequest) (*Note, error)
	// Updates an existing `Note`.
	UpdateNote(context.Context, *UpdateNoteRequest) (*Note, error)
	// Lists `Occurrences` referencing the specified `Note`. Use this method to
	// get all occurrences referencing your `Note` across all your customer
	// projects.
	ListNoteOccurrences(context.Context, *ListNoteOccurrencesRequest) (*ListNoteOccurrencesResponse, error)
}

func RegisterGrafeasServer(s *grpc.Server, srv GrafeasServer) {
	s.RegisterService(&_Grafeas_serviceDesc, srv)
}

func _Grafeas_GetOccurrence_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetOccurrenceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GrafeasServer).GetOccurrence(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/grafeas.v1alpha1.api.Grafeas/GetOccurrence",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GrafeasServer).GetOccurrence(ctx, req.(*GetOccurrenceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Grafeas_ListOccurrences_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListOccurrencesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GrafeasServer).ListOccurrences(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/grafeas.v1alpha1.api.Grafeas/ListOccurrences",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GrafeasServer).ListOccurrences(ctx, req.(*ListOccurrencesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Grafeas_DeleteOccurrence_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteOccurrenceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GrafeasServer).DeleteOccurrence(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/grafeas.v1alpha1.api.Grafeas/DeleteOccurrence",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GrafeasServer).DeleteOccurrence(ctx, req.(*DeleteOccurrenceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Grafeas_CreateOccurrence_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateOccurrenceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GrafeasServer).CreateOccurrence(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/grafeas.v1alpha1.api.Grafeas/CreateOccurrence",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GrafeasServer).CreateOccurrence(ctx, req.(*CreateOccurrenceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Grafeas_UpdateOccurrence_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateOccurrenceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GrafeasServer).UpdateOccurrence(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/grafeas.v1alpha1.api.Grafeas/UpdateOccurrence",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GrafeasServer).UpdateOccurrence(ctx, req.(*UpdateOccurrenceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Grafeas_GetOccurrenceNote_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetOccurrenceNoteRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GrafeasServer).GetOccurrenceNote(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/grafeas.v1alpha1.api.Grafeas/GetOccurrenceNote",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GrafeasServer).GetOccurrenceNote(ctx, req.(*GetOccurrenceNoteRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Grafeas_CreateOperation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateOperationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GrafeasServer).CreateOperation(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/grafeas.v1alpha1.api.Grafeas/CreateOperation",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GrafeasServer).CreateOperation(ctx, req.(*CreateOperationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Grafeas_UpdateOperation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateOperationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GrafeasServer).UpdateOperation(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/grafeas.v1alpha1.api.Grafeas/UpdateOperation",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GrafeasServer).UpdateOperation(ctx, req.(*UpdateOperationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Grafeas_GetNote_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetNoteRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GrafeasServer).GetNote(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/grafeas.v1alpha1.api.Grafeas/GetNote",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GrafeasServer).GetNote(ctx, req.(*GetNoteRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Grafeas_ListNotes_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListNotesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GrafeasServer).ListNotes(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/grafeas.v1alpha1.api.Grafeas/ListNotes",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GrafeasServer).ListNotes(ctx, req.(*ListNotesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Grafeas_DeleteNote_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteNoteRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GrafeasServer).DeleteNote(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/grafeas.v1alpha1.api.Grafeas/DeleteNote",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GrafeasServer).DeleteNote(ctx, req.(*DeleteNoteRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Grafeas_CreateNote_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateNoteRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GrafeasServer).CreateNote(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/grafeas.v1alpha1.api.Grafeas/CreateNote",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GrafeasServer).CreateNote(ctx, req.(*CreateNoteRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Grafeas_UpdateNote_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateNoteRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GrafeasServer).UpdateNote(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/grafeas.v1alpha1.api.Grafeas/UpdateNote",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GrafeasServer).UpdateNote(ctx, req.(*UpdateNoteRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Grafeas_ListNoteOccurrences_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListNoteOccurrencesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GrafeasServer).ListNoteOccurrences(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/grafeas.v1alpha1.api.Grafeas/ListNoteOccurrences",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GrafeasServer).ListNoteOccurrences(ctx, req.(*ListNoteOccurrencesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _Grafeas_serviceDesc = grpc.ServiceDesc{
	ServiceName: "grafeas.v1alpha1.api.Grafeas",
	HandlerType: (*GrafeasServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetOccurrence",
			Handler:    _Grafeas_GetOccurrence_Handler,
		},
		{
			MethodName: "ListOccurrences",
			Handler:    _Grafeas_ListOccurrences_Handler,
		},
		{
			MethodName: "DeleteOccurrence",
			Handler:    _Grafeas_DeleteOccurrence_Handler,
		},
		{
			MethodName: "CreateOccurrence",
			Handler:    _Grafeas_CreateOccurrence_Handler,
		},
		{
			MethodName: "UpdateOccurrence",
			Handler:    _Grafeas_UpdateOccurrence_Handler,
		},
		{
			MethodName: "GetOccurrenceNote",
			Handler:    _Grafeas_GetOccurrenceNote_Handler,
		},
		{
			MethodName: "CreateOperation",
			Handler:    _Grafeas_CreateOperation_Handler,
		},
		{
			MethodName: "UpdateOperation",
			Handler:    _Grafeas_UpdateOperation_Handler,
		},
		{
			MethodName: "GetNote",
			Handler:    _Grafeas_GetNote_Handler,
		},
		{
			MethodName: "ListNotes",
			Handler:    _Grafeas_ListNotes_Handler,
		},
		{
			MethodName: "DeleteNote",
			Handler:    _Grafeas_DeleteNote_Handler,
		},
		{
			MethodName: "CreateNote",
			Handler:    _Grafeas_CreateNote_Handler,
		},
		{
			MethodName: "UpdateNote",
			Handler:    _Grafeas_UpdateNote_Handler,
		},
		{
			MethodName: "ListNoteOccurrences",
			Handler:    _Grafeas_ListNoteOccurrences_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "v1alpha1/proto/grafeas.proto",
}

// Client API for GrafeasProjects service

type GrafeasProjectsClient interface {
	// Creates a new `Project`.
	CreateProject(ctx context.Context, in *CreateProjectRequest, opts ...grpc.CallOption) (*google_protobuf.Empty, error)
	// Returns the requested `Project`.
	GetProject(ctx context.Context, in *GetProjectRequest, opts ...grpc.CallOption) (*Project, error)
	// Lists `Projects`
	ListProjects(ctx context.Context, in *ListProjectsRequest, opts ...grpc.CallOption) (*ListProjectsResponse, error)
	// Deletes the given `Project` from the system.
	DeleteProject(ctx context.Context, in *DeleteProjectRequest, opts ...grpc.CallOption) (*google_protobuf.Empty, error)
}

type grafeasProjectsClient struct {
	cc *grpc.ClientConn
}

func NewGrafeasProjectsClient(cc *grpc.ClientConn) GrafeasProjectsClient {
	return &grafeasProjectsClient{cc}
}

func (c *grafeasProjectsClient) CreateProject(ctx context.Context, in *CreateProjectRequest, opts ...grpc.CallOption) (*google_protobuf.Empty, error) {
	out := new(google_protobuf.Empty)
	err := grpc.Invoke(ctx, "/grafeas.v1alpha1.api.GrafeasProjects/CreateProject", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *grafeasProjectsClient) GetProject(ctx context.Context, in *GetProjectRequest, opts ...grpc.CallOption) (*Project, error) {
	out := new(Project)
	err := grpc.Invoke(ctx, "/grafeas.v1alpha1.api.GrafeasProjects/GetProject", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *grafeasProjectsClient) ListProjects(ctx context.Context, in *ListProjectsRequest, opts ...grpc.CallOption) (*ListProjectsResponse, error) {
	out := new(ListProjectsResponse)
	err := grpc.Invoke(ctx, "/grafeas.v1alpha1.api.GrafeasProjects/ListProjects", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *grafeasProjectsClient) DeleteProject(ctx context.Context, in *DeleteProjectRequest, opts ...grpc.CallOption) (*google_protobuf.Empty, error) {
	out := new(google_protobuf.Empty)
	err := grpc.Invoke(ctx, "/grafeas.v1alpha1.api.GrafeasProjects/DeleteProject", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for GrafeasProjects service

type GrafeasProjectsServer interface {
	// Creates a new `Project`.
	CreateProject(context.Context, *CreateProjectRequest) (*google_protobuf.Empty, error)
	// Returns the requested `Project`.
	GetProject(context.Context, *GetProjectRequest) (*Project, error)
	// Lists `Projects`
	ListProjects(context.Context, *ListProjectsRequest) (*ListProjectsResponse, error)
	// Deletes the given `Project` from the system.
	DeleteProject(context.Context, *DeleteProjectRequest) (*google_protobuf.Empty, error)
}

func RegisterGrafeasProjectsServer(s *grpc.Server, srv GrafeasProjectsServer) {
	s.RegisterService(&_GrafeasProjects_serviceDesc, srv)
}

func _GrafeasProjects_CreateProject_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateProjectRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GrafeasProjectsServer).CreateProject(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/grafeas.v1alpha1.api.GrafeasProjects/CreateProject",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GrafeasProjectsServer).CreateProject(ctx, req.(*CreateProjectRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _GrafeasProjects_GetProject_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetProjectRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GrafeasProjectsServer).GetProject(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/grafeas.v1alpha1.api.GrafeasProjects/GetProject",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GrafeasProjectsServer).GetProject(ctx, req.(*GetProjectRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _GrafeasProjects_ListProjects_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListProjectsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GrafeasProjectsServer).ListProjects(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/grafeas.v1alpha1.api.GrafeasProjects/ListProjects",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GrafeasProjectsServer).ListProjects(ctx, req.(*ListProjectsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _GrafeasProjects_DeleteProject_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteProjectRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GrafeasProjectsServer).DeleteProject(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/grafeas.v1alpha1.api.GrafeasProjects/DeleteProject",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GrafeasProjectsServer).DeleteProject(ctx, req.(*DeleteProjectRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _GrafeasProjects_serviceDesc = grpc.ServiceDesc{
	ServiceName: "grafeas.v1alpha1.api.GrafeasProjects",
	HandlerType: (*GrafeasProjectsServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateProject",
			Handler:    _GrafeasProjects_CreateProject_Handler,
		},
		{
			MethodName: "GetProject",
			Handler:    _GrafeasProjects_GetProject_Handler,
		},
		{
			MethodName: "ListProjects",
			Handler:    _GrafeasProjects_ListProjects_Handler,
		},
		{
			MethodName: "DeleteProject",
			Handler:    _GrafeasProjects_DeleteProject_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "v1alpha1/proto/grafeas.proto",
}

func init() { proto.RegisterFile("v1alpha1/proto/grafeas.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 4671 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xc4, 0x3b, 0xcf, 0x6f, 0x23, 0xd7,
	0x79, 0x1a, 0xfe, 0xe6, 0x47, 0x4a, 0x1a, 0xbd, 0xd5, 0xee, 0x2a, 0x5c, 0x6f, 0x76, 0x33, 0x6b,
	0x7b, 0xd7, 0x72, 0x4c, 0x79, 0x65, 0x7b, 0x1d, 0xdb, 0x75, 0x1d, 0x8a, 0xe4, 0x8a, 0x53, 0xf1,
	0x87, 0x30, 0xa4, 0xd6, 0xbb, 0x6d, 0x91, 0xe9, 0x88, 0xf3, 0x44, 0x4d, 0x44, 0x72, 0x98, 0x99,
	0xa1, 0xb2, 0x72, 0xe0, 0xa0, 0x0d, 0x1c, 0x14, 0x01, 0x7a, 0x08, 0x90, 0x06, 0xe8, 0xa1, 0x87,
	0x34, 0x87, 0x1e, 0x8a, 0x02, 0x3d, 0x14, 0x3d, 0xf6, 0x1c, 0xf4, 0x54, 0x04, 0x45, 0xff, 0x83,
	0xa2, 0x45, 0x5b, 0xa0, 0x28, 0x7a, 0xe9, 0xb1, 0xc5, 0xfb, 0x35, 0x33, 0xa4, 0x86, 0xd4, 0xac,
	0x37, 0x41, 0x2e, 0x12, 0xdf, 0x37, 0xdf, 0xf7, 0xbd, 0xef, 0xbd, 0xef, 0xf7, 0x9b, 0x79, 0xf0,
	0xca, 0xf9, 0x43, 0x63, 0x38, 0x39, 0x35, 0x1e, 0xee, 0x4c, 0x1c, 0xdb, 0xb3, 0x77, 0x06, 0x8e,
	0x71, 0x82, 0x0d, 0xb7, 0x4c, 0x47, 0x68, 0x53, 0x0c, 0x05, 0x56, 0xd9, 0x98, 0x58, 0xa5, 0x5b,
	0x03, 0xdb, 0x1e, 0x0c, 0x31, 0xa3, 0x38, 0x9e, 0x9e, 0xec, 0xe0, 0xd1, 0xc4, 0xbb, 0x60, 0x24,
	0xa5, 0x57, 0xf8, 0x43, 0x63, 0x62, 0xed, 0x18, 0xe3, 0xb1, 0xed, 0x19, 0x9e, 0x65, 0x8f, 0x39,
	0xc3, 0xd2, 0xdd, 0x79, 0xd2, 0x13, 0x0b, 0x0f, 0x4d, 0x7d, 0x64, 0xb8, 0x67, 0x1c, 0xe3, 0xce,
	0x3c, 0x86, 0x67, 0x8d, 0xb0, 0xeb, 0x19, 0xa3, 0x09, 0x47, 0xb8, 0xc7, 0x11, 0x86, 0xf6, 0x78,
	0xe0, 0x4c, 0xc7, 0x63, 0x6b, 0x3c, 0xd8, 0xb1, 0x27, 0xd8, 0x09, 0xcf, 0xa3, 0x6c, 0xc3, 0x66,
	0xd5, 0xc1, 0x86, 0x87, 0x0f, 0x1d, 0xfb, 0xdb, 0xb8, 0xef, 0x69, 0xf8, 0x3b, 0x53, 0xec, 0x7a,
	0x08, 0x41, 0x6a, 0x6c, 0x8c, 0xf0, 0x96, 0x74, 0x57, 0x7a, 0x90, 0xd7, 0xe8, 0x6f, 0xe5, 0x3e,
	0x6c, 0xec, 0x63, 0x2f, 0x06, 0xa2, 0x05, 0xd7, 0x9a, 0x96, 0x2b, 0x30, 0x5d, 0x81, 0x7a, 0x03,
	0x32, 0x27, 0xd6, 0xd0, 0xc3, 0x0e, 0x47, 0xe6, 0x23, 0x74, 0x0b, 0xf2, 0x13, 0x63, 0x80, 0x75,
	0xd7, 0xfa, 0x0c, 0x6f, 0x25, 0xee, 0x4a, 0x0f, 0xd2, 0x5a, 0x8e, 0x00, 0xba, 0xd6, 0x67, 0x18,
	0xdd, 0x06, 0xa0, 0x0f, 0x3d, 0xfb, 0x0c, 0x8f, 0xb7, 0x92, 0x94, 0x90, 0xa2, 0xf7, 0x08, 0x80,
	0xc8, 0x5f, 0xc3, 0x43, 0x1c, 0x4b, 0xfe, 0x6d, 0xd8, 0xdc, 0xc7, 0x5e, 0xa7, 0xdf, 0x9f, 0x3a,
	0x0e, 0x1e, 0xf7, 0xf1, 0x32, 0xdc, 0x2f, 0x24, 0xb8, 0x41, 0xd6, 0x10, 0x60, 0x87, 0x97, 0x31,
	0x31, 0x1c, 0x3c, 0xf6, 0xb6, 0xd2, 0x6c, 0x19, 0x6c, 0x14, 0x5a, 0x5e, 0x62, 0xf1, 0xf2, 0x92,
	0x4b, 0x97, 0x97, 0x9a, 0x5f, 0xde, 0x5b, 0x70, 0x93, 0x2d, 0x2f, 0x9e, 0xd4, 0x2e, 0xdc, 0x64,
	0xda, 0xbc, 0x8c, 0x1e, 0x48, 0x9d, 0x9c, 0x91, 0xfa, 0x9b, 0x00, 0xb6, 0x8f, 0x4c, 0x25, 0x2f,
	0xec, 0xde, 0x2d, 0x47, 0x99, 0x73, 0x39, 0xc4, 0x34, 0x44, 0xa3, 0xfc, 0xb5, 0x04, 0x37, 0x8f,
	0x26, 0xa6, 0x11, 0x53, 0xc8, 0x97, 0x9f, 0x11, 0x7d, 0x04, 0x85, 0x29, 0x9d, 0x90, 0xfa, 0x03,
	0x5d, 0x50, 0x61, 0xb7, 0x54, 0x66, 0xf6, 0x5e, 0x16, 0x0e, 0x51, 0x7e, 0x4c, 0x5c, 0xa6, 0x65,
	0xb8, 0x67, 0x1a, 0x30, 0x74, 0xf2, 0x5b, 0x79, 0x15, 0xd6, 0xf6, 0xb1, 0xd7, 0xb6, 0xbd, 0xa5,
	0x3b, 0x59, 0x86, 0xad, 0x19, 0x5b, 0xb9, 0x0a, 0xff, 0xfb, 0x20, 0x13, 0x73, 0x21, 0x68, 0xbf,
	0x11, 0x43, 0xb9, 0x0f, 0x1b, 0xcc, 0x50, 0xae, 0x12, 0xd4, 0x83, 0x0d, 0x66, 0x22, 0x61, 0xc4,
	0x40, 0xd2, 0xd4, 0x8c, 0xa4, 0x37, 0x21, 0x3b, 0xb6, 0x3d, 0xac, 0x5b, 0xa6, 0x10, 0x95, 0x0c,
	0x55, 0x13, 0x95, 0x21, 0x45, 0x7e, 0x05, 0x5b, 0x1f, 0xa5, 0x3d, 0x3a, 0x03, 0xc5, 0x53, 0xfe,
	0x54, 0x82, 0x0d, 0x66, 0x23, 0x57, 0xc8, 0xe7, 0x73, 0x4e, 0xc4, 0xe3, 0xfc, 0x72, 0xb6, 0xf0,
	0x85, 0x04, 0x25, 0xa1, 0xb6, 0x08, 0x4f, 0x8f, 0x92, 0xef, 0xd7, 0xa1, 0xbc, 0x0b, 0xd8, 0x9c,
	0x8d, 0x97, 0xee, 0xc4, 0x1e, 0xbb, 0x18, 0x7d, 0x00, 0xb9, 0x09, 0x87, 0x6d, 0x49, 0x77, 0x93,
	0x0f, 0x0a, 0xbb, 0xb7, 0xa3, 0xf7, 0x43, 0x04, 0x3f, 0x1f, 0x1d, 0xbd, 0x0e, 0xeb, 0x63, 0xfc,
	0xdc, 0xd3, 0x43, 0xd3, 0x32, 0x79, 0x57, 0x09, 0xf8, 0xd0, 0x9f, 0xfa, 0x47, 0x12, 0xdc, 0x8a,
	0xdc, 0x01, 0x2e, 0xc2, 0x1e, 0x14, 0x02, 0xc7, 0x13, 0x52, 0x5c, 0xed, 0xad, 0x61, 0xa2, 0xd8,
	0xb2, 0x8c, 0x60, 0x23, 0xe4, 0x43, 0x5c, 0x80, 0xb7, 0x21, 0x4d, 0xf4, 0x2c, 0xa6, 0x5e, 0x66,
	0x10, 0x0c, 0x31, 0xf6, 0x74, 0x3f, 0x94, 0xe0, 0xe6, 0xa5, 0x10, 0xff, 0x1b, 0x58, 0xf6, 0xe7,
	0x3c, 0xd3, 0xf8, 0xa9, 0xd9, 0x97, 0xe2, 0x55, 0x98, 0x45, 0xe5, 0x86, 0x38, 0x0b, 0x44, 0x1f,
	0x03, 0x04, 0x69, 0x7d, 0x2b, 0x21, 0xec, 0x84, 0x39, 0x40, 0x28, 0xf9, 0x97, 0xfd, 0x19, 0xb4,
	0x10, 0x81, 0x62, 0xc1, 0x0d, 0x1e, 0xbd, 0xfd, 0xc7, 0x4b, 0xcc, 0xff, 0x23, 0xc8, 0xfb, 0xb4,
	0xdc, 0xd9, 0xae, 0x98, 0x2b, 0xc0, 0x57, 0x7e, 0x2c, 0xc1, 0x0d, 0x9e, 0x9f, 0xe6, 0xe7, 0x0a,
	0x22, 0x90, 0x34, 0x13, 0x81, 0xbe, 0x06, 0x45, 0x9f, 0x3e, 0x08, 0x43, 0x05, 0x1f, 0xa6, 0x9a,
	0x2f, 0x27, 0xd2, 0x6d, 0xc8, 0x72, 0xe7, 0x89, 0x8c, 0x96, 0x7f, 0x2c, 0xc1, 0x86, 0x4f, 0xd7,
	0xc2, 0x9e, 0x61, 0x1a, 0x9e, 0x41, 0x62, 0x4e, 0x9f, 0x2e, 0x43, 0x27, 0x35, 0x17, 0x25, 0x88,
	0x8a, 0x39, 0x3d, 0x51, 0x90, 0x69, 0xc0, 0xd0, 0x09, 0x00, 0xbd, 0x07, 0x39, 0x3c, 0x36, 0x19,
	0x65, 0xe2, 0x4a, 0xca, 0x2c, 0x1e, 0x9b, 0x64, 0xa4, 0xfc, 0x01, 0xe4, 0x2a, 0x8e, 0x67, 0x9d,
	0x18, 0xd1, 0x92, 0xa2, 0x12, 0xe4, 0xfa, 0xa7, 0xb8, 0x7f, 0xe6, 0x4e, 0x47, 0x7c, 0x93, 0xfc,
	0x31, 0x5a, 0x83, 0x84, 0x65, 0xf2, 0xbc, 0x9f, 0xb0, 0x4c, 0xb4, 0x09, 0x69, 0x42, 0xe3, 0x6e,
	0xa5, 0xee, 0x26, 0x1f, 0xe4, 0x35, 0x36, 0x50, 0xfe, 0x31, 0x01, 0x9b, 0x15, 0xcf, 0x23, 0x13,
	0x93, 0xd5, 0x56, 0xa6, 0xde, 0xa9, 0xed, 0x58, 0xde, 0x05, 0xfa, 0x14, 0x52, 0xa7, 0x16, 0xd7,
	0x4c, 0x61, 0xb7, 0x1a, 0xed, 0x05, 0x51, 0x94, 0x91, 0xc0, 0x86, 0x35, 0xf6, 0x34, 0xca, 0xb0,
	0xf4, 0x2d, 0xd8, 0x5a, 0x84, 0x81, 0xca, 0x70, 0xed, 0x74, 0x3a, 0x32, 0xc6, 0xba, 0x83, 0x0d,
	0xd3, 0x38, 0x1e, 0x62, 0x3d, 0xb4, 0xe4, 0x0d, 0xfa, 0x48, 0xe3, 0x4f, 0xda, 0x64, 0xfd, 0x08,
	0x52, 0x67, 0xf8, 0x82, 0xd9, 0x7f, 0x5e, 0xa3, 0xbf, 0x4b, 0xdf, 0x87, 0x42, 0x88, 0x3f, 0x3a,
	0x86, 0x1b, 0x93, 0xc1, 0x44, 0x77, 0xad, 0xc1, 0x18, 0x9b, 0xba, 0x11, 0x3c, 0xe1, 0x2b, 0xdb,
	0x5e, 0x10, 0x5c, 0x07, 0x93, 0x2e, 0x25, 0x09, 0xf1, 0x6a, 0xac, 0x68, 0x9b, 0x93, 0x08, 0xf8,
	0x5e, 0x01, 0xf2, 0x84, 0xbf, 0xe1, 0x4d, 0x1d, 0xac, 0xfc, 0xa1, 0x04, 0xc5, 0xbd, 0xa9, 0x35,
	0x34, 0x6b, 0xd8, 0x33, 0xac, 0xa1, 0x8b, 0xea, 0x00, 0x13, 0xc7, 0x3e, 0xc7, 0x63, 0x83, 0x94,
	0x3e, 0x6c, 0xd6, 0xd7, 0xa2, 0x67, 0xa5, 0x74, 0x87, 0x3e, 0xb2, 0x16, 0x22, 0x44, 0x6f, 0x80,
	0x1c, 0x8c, 0xf4, 0xe3, 0x0b, 0x12, 0x1e, 0x99, 0xce, 0xd7, 0x03, 0xf8, 0x1e, 0x01, 0x2b, 0xff,
	0x9a, 0x86, 0xf5, 0x39, 0x56, 0xdc, 0x1c, 0x24, 0xdf, 0x1c, 0x6e, 0x53, 0xa9, 0x88, 0x0f, 0x04,
	0x1e, 0x96, 0xe7, 0x10, 0xd5, 0x24, 0x59, 0xa8, 0x6f, 0x8f, 0x46, 0xc6, 0xd8, 0x74, 0xb7, 0xd2,
	0xcb, 0xb2, 0x50, 0x95, 0x61, 0x69, 0x3e, 0x3a, 0xda, 0x87, 0xf5, 0xe3, 0xa9, 0x35, 0xf4, 0x74,
	0x83, 0x9b, 0xae, 0xbb, 0x95, 0xa1, 0x1c, 0xbe, 0xba, 0xc0, 0x88, 0x38, 0x9a, 0xb6, 0x46, 0xc9,
	0xc4, 0xd0, 0x9d, 0xf7, 0xb8, 0xec, 0x0b, 0x79, 0xdc, 0x07, 0x00, 0xae, 0x67, 0x38, 0x1e, 0xa3,
	0xcd, 0x5d, 0x49, 0x9b, 0xa7, 0xd8, 0x94, 0xf4, 0x23, 0x28, 0x9c, 0x58, 0x63, 0xcb, 0x3d, 0x65,
	0xb4, 0xf9, 0xab, 0xe7, 0x65, 0xe8, 0x94, 0x78, 0x0b, 0xb2, 0x54, 0x0a, 0xdb, 0xd9, 0x2a, 0xd0,
	0x4d, 0x15, 0x43, 0x74, 0x07, 0x0a, 0x43, 0x7b, 0xe0, 0xea, 0xc7, 0xd3, 0xfe, 0x19, 0xf6, 0xb6,
	0x56, 0xe9, 0x53, 0x20, 0xa0, 0x3d, 0x0a, 0x41, 0x2a, 0x6c, 0xb8, 0xf6, 0xd4, 0xe9, 0x63, 0x3d,
	0x64, 0x2f, 0x6b, 0x74, 0xf6, 0x57, 0xa2, 0xb7, 0xae, 0x4b, 0xd1, 0x35, 0x99, 0x91, 0x85, 0xb4,
	0x7d, 0x1b, 0xc0, 0x73, 0xac, 0xc1, 0x00, 0x3b, 0x44, 0xbb, 0xeb, 0x4c, 0xbb, 0x1c, 0xa2, 0x9a,
	0xe8, 0xf7, 0x61, 0x95, 0xec, 0xb5, 0xa9, 0xdb, 0x13, 0x96, 0x40, 0x64, 0xaa, 0xa0, 0xf7, 0x63,
	0x59, 0x25, 0x1b, 0x77, 0x18, 0x65, 0x7d, 0xec, 0x39, 0x17, 0x5a, 0xf1, 0x38, 0x04, 0x42, 0xf7,
	0x99, 0x01, 0x98, 0xd8, 0xd1, 0xcf, 0xb1, 0xe3, 0x12, 0x5f, 0xdb, 0xa0, 0x12, 0xac, 0x71, 0xf0,
	0x13, 0x06, 0x2d, 0x7d, 0x02, 0x1b, 0x97, 0x78, 0x21, 0x19, 0x92, 0x67, 0xf8, 0x82, 0x5b, 0x2a,
	0xf9, 0x49, 0x22, 0xd7, 0xb9, 0x31, 0x9c, 0x62, 0x6e, 0xa5, 0x6c, 0xf0, 0x61, 0xe2, 0x1b, 0x92,
	0xf2, 0xbf, 0x12, 0xac, 0x51, 0x0e, 0x5d, 0xe1, 0x7e, 0xd4, 0xae, 0xa7, 0xc7, 0x43, 0xab, 0xaf,
	0x07, 0x5c, 0xf2, 0x0c, 0x72, 0x80, 0x2f, 0xd0, 0x2b, 0x21, 0x57, 0x15, 0x56, 0xef, 0x03, 0xd0,
	0x75, 0xc8, 0x9c, 0xe1, 0x0b, 0xdd, 0x8f, 0x9b, 0xe9, 0x33, 0x7c, 0xa1, 0x9a, 0x68, 0x1f, 0x72,
	0x04, 0xec, 0x5d, 0x4c, 0x30, 0xad, 0xe3, 0xd6, 0x76, 0xbf, 0xbe, 0x64, 0xa7, 0x7c, 0x59, 0xca,
	0x07, 0xf8, 0xa2, 0x77, 0x31, 0xc1, 0x5a, 0xf6, 0x8c, 0xfd, 0x50, 0x1a, 0x90, 0xe5, 0x30, 0xb4,
	0x05, 0x9b, 0x07, 0xf5, 0x67, 0x7a, 0xef, 0xd9, 0x61, 0x5d, 0x3f, 0x6a, 0x77, 0x0f, 0xeb, 0x55,
	0xf5, 0xb1, 0x5a, 0xaf, 0xc9, 0x2b, 0xe8, 0x3a, 0x6c, 0x1c, 0xee, 0x1f, 0xea, 0x95, 0x6e, 0x55,
	0x55, 0xf5, 0x8a, 0xd6, 0xea, 0x68, 0xf5, 0x9a, 0x2c, 0xa1, 0x22, 0xe4, 0x0e, 0x0f, 0xd4, 0xa7,
	0xfa, 0x61, 0xbd, 0x25, 0x27, 0x94, 0xe7, 0x90, 0xa7, 0x93, 0x51, 0x5e, 0x11, 0x1b, 0x2e, 0x45,
	0x6d, 0x38, 0xda, 0x9b, 0x5f, 0x7d, 0x61, 0xf7, 0xd5, 0x38, 0x2b, 0xd1, 0x66, 0xe3, 0x5b, 0x96,
	0x3b, 0x7d, 0x64, 0x4e, 0x92, 0x21, 0x89, 0xc7, 0xe7, 0x3c, 0x24, 0x93, 0x9f, 0x04, 0xcb, 0x70,
	0x06, 0xee, 0x56, 0x92, 0x45, 0x69, 0xf2, 0x9b, 0x60, 0x99, 0x96, 0xc3, 0xab, 0x62, 0xf2, 0x93,
	0x07, 0xa8, 0xb4, 0x1f, 0xa0, 0xbe, 0x02, 0xb9, 0xef, 0x1a, 0x96, 0xa7, 0x9f, 0xd8, 0x0e, 0x8d,
	0x1f, 0x79, 0x2d, 0x4b, 0xc6, 0x8f, 0x6d, 0x47, 0xf9, 0x45, 0x12, 0xa0, 0x86, 0x27, 0x43, 0xfb,
	0x82, 0x64, 0x02, 0x52, 0x2e, 0x38, 0x98, 0x7b, 0xce, 0xd4, 0xb1, 0x68, 0xe1, 0x96, 0xd7, 0x0a,
	0x02, 0x76, 0xe4, 0x58, 0xa5, 0x9f, 0xfa, 0x14, 0x23, 0x52, 0x60, 0xdc, 0x06, 0x98, 0xba, 0xd8,
	0xd1, 0xf1, 0xc8, 0xb0, 0x86, 0xc2, 0x48, 0x08, 0xa4, 0x4e, 0x00, 0x24, 0x00, 0x98, 0x14, 0x39,
	0x6e, 0xc2, 0x06, 0x86, 0x4e, 0x03, 0xc0, 0x27, 0xb0, 0x3a, 0x1d, 0x87, 0xc9, 0x93, 0x57, 0x92,
	0x17, 0x05, 0x01, 0x65, 0x70, 0x03, 0x32, 0x7d, 0x7b, 0x7c, 0x62, 0x0d, 0x68, 0xd4, 0xca, 0x6b,
	0x7c, 0x44, 0x22, 0x8b, 0x61, 0x9a, 0x0e, 0x76, 0x5d, 0xbe, 0x4b, 0x62, 0x78, 0x69, 0x03, 0x32,
	0x97, 0x36, 0x00, 0x1d, 0x42, 0x6e, 0x32, 0x34, 0xbc, 0x13, 0xdb, 0x19, 0xd1, 0x40, 0xba, 0xb6,
	0xfb, 0x6e, 0xb4, 0xe2, 0x83, 0x7d, 0x2d, 0x07, 0x1b, 0x56, 0x3e, 0xe4, 0xb4, 0x9a, 0xcf, 0x45,
	0xa9, 0x42, 0x4e, 0x40, 0x89, 0x31, 0x1f, 0x36, 0x2b, 0xbd, 0xc7, 0x1d, 0xad, 0x35, 0x67, 0xcc,
	0x59, 0x48, 0xee, 0x1f, 0xd4, 0x65, 0x09, 0xe5, 0x20, 0xf5, 0xb8, 0x59, 0x7f, 0x2a, 0x27, 0x10,
	0x40, 0xa6, 0x7a, 0xd4, 0xed, 0x75, 0x5a, 0x72, 0x52, 0xf9, 0xfb, 0x0c, 0x14, 0x6a, 0x76, 0xff,
	0x0c, 0x3b, 0xea, 0xc8, 0x18, 0xe0, 0xd2, 0xbf, 0x27, 0x20, 0xdd, 0x34, 0x2e, 0xb0, 0x83, 0x3a,
	0x90, 0x37, 0x2d, 0x07, 0xf7, 0x3d, 0xeb, 0x9c, 0xd9, 0xd7, 0xda, 0xee, 0xc3, 0x05, 0x12, 0x07,
	0xf4, 0x65, 0x4a, 0x5b, 0xae, 0x09, 0x42, 0x2d, 0xe0, 0x41, 0x3c, 0xdf, 0x70, 0x06, 0x53, 0xb2,
	0x1c, 0x91, 0x38, 0x03, 0x80, 0xf2, 0xdf, 0x12, 0xe4, 0x7d, 0x32, 0xf4, 0x15, 0xb8, 0x5e, 0x53,
	0xb5, 0x7a, 0xb5, 0xa7, 0x3e, 0x99, 0xf7, 0xce, 0x35, 0x80, 0x56, 0x45, 0x6d, 0xf7, 0x2a, 0x6a,
	0xbb, 0xae, 0xc9, 0x12, 0x59, 0xa0, 0x76, 0xd4, 0x96, 0x13, 0xe4, 0x47, 0xb5, 0x55, 0x93, 0x93,
	0x28, 0x0f, 0xe9, 0x66, 0x65, 0xaf, 0xde, 0x94, 0x53, 0x64, 0xa9, 0xf5, 0xa7, 0x87, 0x9d, 0x6e,
	0x5d, 0x4e, 0x93, 0xe7, 0xf5, 0xf6, 0x13, 0x39, 0x43, 0x7e, 0x54, 0x6a, 0x35, 0x39, 0x4b, 0xb6,
	0xa4, 0xda, 0x39, 0x7c, 0x26, 0xe7, 0x08, 0xd3, 0x7a, 0xbb, 0xa7, 0x3d, 0x3b, 0xec, 0xa8, 0xed,
	0x9e, 0x9c, 0x27, 0x74, 0x4f, 0x3a, 0xcd, 0xa3, 0x56, 0x5d, 0x06, 0x82, 0x75, 0xd4, 0xad, 0x6b,
	0x72, 0x01, 0x15, 0x20, 0xfb, 0x69, 0x47, 0x3b, 0xa8, 0xa9, 0x9a, 0x5c, 0xa4, 0x5c, 0xb4, 0x7d,
	0x79, 0x95, 0x40, 0x3b, 0xed, 0xbd, 0x23, 0xb5, 0x59, 0x93, 0xd7, 0x08, 0xa3, 0x6e, 0xaf, 0x73,
	0xd8, 0x55, 0xf7, 0xdb, 0x95, 0xa6, 0xbc, 0x8e, 0xd6, 0xa1, 0xd0, 0xa8, 0x57, 0x9a, 0xbd, 0x46,
	0xb5, 0x51, 0xaf, 0x1e, 0xc8, 0x32, 0x11, 0xae, 0xdb, 0xa8, 0x37, 0x9b, 0xf2, 0x46, 0xe9, 0x29,
	0x14, 0x1e, 0x5b, 0xe3, 0x01, 0x76, 0x26, 0x8e, 0xc5, 0xda, 0xfe, 0xf3, 0x87, 0xe1, 0x7a, 0x2b,
	0x73, 0xfe, 0x90, 0x16, 0x59, 0xe4, 0xc1, 0xae, 0x7e, 0x3c, 0xb4, 0x8f, 0xb9, 0x53, 0x67, 0xce,
	0x77, 0xf7, 0x86, 0xf6, 0x31, 0x7f, 0x40, 0x29, 0xf8, 0xf1, 0xd2, 0xf9, 0x2e, 0xa1, 0x28, 0x7d,
	0x0f, 0xd2, 0x7b, 0x86, 0x6b, 0xcd, 0x1b, 0xa6, 0xf0, 0xb4, 0x90, 0x61, 0x0e, 0x51, 0x87, 0x26,
	0x5b, 0x21, 0x05, 0xf7, 0xb5, 0xb7, 0xae, 0xd6, 0x74, 0x48, 0x74, 0x2d, 0xcc, 0xa1, 0xf4, 0x1f,
	0x12, 0x64, 0x6b, 0xd8, 0xb1, 0xce, 0xb1, 0x39, 0xcf, 0x5c, 0x7a, 0x59, 0xe6, 0xa4, 0xe0, 0x36,
	0x2d, 0xd7, 0x33, 0xc4, 0x21, 0xd6, 0xaa, 0xe6, 0x8f, 0xd1, 0x63, 0x80, 0x21, 0x31, 0x3f, 0xdd,
	0x1a, 0x9f, 0xd8, 0x34, 0xd8, 0x15, 0x76, 0xef, 0xc7, 0x34, 0x59, 0x2d, 0x4f, 0x49, 0xd5, 0xf1,
	0x89, 0x8d, 0xb6, 0x61, 0xe3, 0xd8, 0x70, 0xb1, 0x3e, 0xb3, 0x73, 0x2c, 0x50, 0xae, 0x93, 0x07,
	0x5a, 0xb0, 0x7b, 0xca, 0x9f, 0x53, 0xb3, 0x75, 0xfb, 0xf6, 0x39, 0x76, 0x2e, 0x50, 0x0d, 0x56,
	0x8d, 0xb1, 0x31, 0xbc, 0x70, 0x2d, 0x57, 0x3f, 0xb3, 0xc6, 0x26, 0xf7, 0x9b, 0x3b, 0x8b, 0xdb,
	0xe7, 0xf2, 0x81, 0x35, 0x36, 0xb5, 0xa2, 0xa0, 0x22, 0xa3, 0x92, 0x0a, 0x20, 0x58, 0xe2, 0xb9,
	0x46, 0x4b, 0x7a, 0xc1, 0x46, 0xab, 0x0e, 0xf0, 0xd8, 0x1a, 0xe2, 0x86, 0xe1, 0x9e, 0x62, 0x17,
	0xbd, 0x0f, 0xf9, 0x13, 0x6b, 0x88, 0xf5, 0x53, 0xc3, 0x3d, 0x5d, 0xde, 0xd9, 0x13, 0x02, 0x2d,
	0x77, 0xc2, 0x49, 0x95, 0xef, 0x42, 0x8a, 0xfc, 0x47, 0xef, 0x43, 0x8a, 0xe6, 0x60, 0xb6, 0xac,
	0x7b, 0x8b, 0x69, 0xe9, 0x1f, 0x9a, 0x7a, 0x29, 0xc1, 0x6c, 0x05, 0x51, 0xe4, 0x15, 0x84, 0x72,
	0x17, 0x72, 0x02, 0x8f, 0x78, 0x59, 0xbb, 0xd3, 0xae, 0xcb, 0x2b, 0xc4, 0xf7, 0xba, 0x8d, 0xca,
	0xee, 0x7b, 0x8f, 0x64, 0x49, 0xf9, 0x79, 0x1e, 0x52, 0x64, 0x9b, 0x22, 0x13, 0xdd, 0x9b, 0xb0,
	0xe1, 0x9e, 0xda, 0x8e, 0xa7, 0x9b, 0xd8, 0xed, 0x3b, 0xd6, 0xc4, 0x6f, 0x45, 0xf3, 0x9a, 0x4c,
	0x1f, 0xd4, 0x02, 0x38, 0xa9, 0xde, 0xc9, 0x6e, 0xcd, 0xe0, 0x72, 0x9d, 0x12, 0x78, 0x18, 0xf5,
	0x1d, 0x48, 0x51, 0xe5, 0xe5, 0xe3, 0x29, 0x8f, 0x22, 0xa3, 0xa7, 0x80, 0xce, 0xa7, 0xc3, 0x31,
	0x76, 0x8c, 0x63, 0x6b, 0x68, 0x79, 0xbc, 0x58, 0xc9, 0x50, 0x7d, 0x2d, 0x30, 0xc2, 0x27, 0x61,
	0x7c, 0xb2, 0x09, 0x8d, 0x15, 0x6d, 0xe3, 0x7c, 0x1e, 0x88, 0x3e, 0x05, 0x39, 0xd4, 0x35, 0x31,
	0xbe, 0xd7, 0x96, 0xb5, 0x4e, 0x91, 0xdd, 0xdd, 0x8a, 0xb6, 0x1e, 0xe2, 0x42, 0x19, 0x7f, 0x13,
	0x80, 0x15, 0xa1, 0x94, 0x25, 0xab, 0xd0, 0xef, 0x2c, 0xa9, 0x46, 0xb8, 0x88, 0xf9, 0x63, 0xbf,
	0xee, 0x69, 0x00, 0x50, 0x4f, 0xb1, 0x88, 0x23, 0xd1, 0x82, 0x3a, 0x96, 0xc7, 0xd1, 0xd8, 0x44,
	0x39, 0x19, 0x2e, 0xa6, 0x20, 0xd4, 0x80, 0xec, 0xc4, 0xe8, 0x9f, 0x11, 0x36, 0xac, 0xe0, 0x5e,
	0x50, 0xe0, 0x1d, 0x32, 0xa4, 0x96, 0x31, 0x36, 0x06, 0xd8, 0x11, 0xc3, 0xc6, 0x8a, 0x26, 0xc8,
	0xd1, 0x1e, 0xf0, 0x62, 0x80, 0xa4, 0x50, 0x5a, 0xf7, 0x2e, 0x3c, 0x43, 0x0a, 0x52, 0x6d, 0x63,
	0x45, 0x0b, 0x51, 0xa1, 0x4f, 0x48, 0xee, 0xe3, 0x4e, 0xbd, 0x85, 0x96, 0x6d, 0x8c, 0xef, 0xfb,
	0x64, 0x39, 0x3e, 0x0d, 0x7a, 0x0c, 0x05, 0x07, 0x0f, 0x0d, 0x0f, 0x9b, 0x34, 0x78, 0x64, 0xa9,
	0xaf, 0xbd, 0xb6, 0xc4, 0x92, 0x34, 0x86, 0x7d, 0xe4, 0x0c, 0x35, 0x70, 0xfc, 0xdf, 0xa8, 0x0a,
	0xeb, 0xf8, 0xf9, 0xc4, 0xe2, 0x27, 0x31, 0xb4, 0x9a, 0x81, 0x2b, 0xab, 0x99, 0xb5, 0x80, 0x44,
	0xb4, 0x53, 0xe1, 0x36, 0xae, 0xf0, 0x42, 0x6d, 0x5c, 0x70, 0xd2, 0x4b, 0x89, 0x8b, 0x57, 0x13,
	0x33, 0x74, 0x02, 0x28, 0xbd, 0x0b, 0x10, 0x2c, 0x8c, 0x94, 0x9c, 0x41, 0x0e, 0x22, 0x3f, 0x49,
	0x58, 0x18, 0x1a, 0xc7, 0x78, 0x28, 0x1a, 0x0b, 0x3a, 0x50, 0x7e, 0x26, 0x41, 0x8a, 0x78, 0x16,
	0xda, 0x04, 0xf9, 0x40, 0x6d, 0xd7, 0xe6, 0x0a, 0x80, 0x75, 0x28, 0x54, 0x7a, 0xbd, 0x7a, 0xb7,
	0x57, 0xe9, 0xa9, 0x9d, 0xb6, 0x2c, 0x91, 0x62, 0xe1, 0xb0, 0x52, 0x3d, 0xa8, 0xec, 0xd7, 0xf5,
	0x27, 0x47, 0xcd, 0x76, 0x5d, 0xab, 0xec, 0xa9, 0x4d, 0xb5, 0xf7, 0x4c, 0x4e, 0xa0, 0x0d, 0x58,
	0xa5, 0x99, 0x59, 0xaf, 0xd5, 0x7b, 0x15, 0xb5, 0xd9, 0x95, 0x93, 0x84, 0x5c, 0x6d, 0x11, 0xdc,
	0xbd, 0x4a, 0x57, 0xed, 0xca, 0x29, 0x74, 0x0d, 0xd6, 0x05, 0x79, 0xab, 0xd2, 0xae, 0xec, 0xd7,
	0x35, 0x39, 0x4d, 0xf2, 0x78, 0xad, 0x7e, 0xd8, 0xec, 0x3c, 0xab, 0xec, 0x35, 0xeb, 0x72, 0x06,
	0xad, 0x42, 0xbe, 0xa6, 0x76, 0xab, 0x9d, 0x27, 0x75, 0xed, 0x99, 0x9c, 0xdd, 0x2b, 0x40, 0x9e,
	0x1e, 0xd1, 0x13, 0xcf, 0x51, 0xfe, 0x26, 0x0b, 0x10, 0x1c, 0x47, 0x46, 0x86, 0xaa, 0xf9, 0x3c,
	0x9c, 0xb8, 0x9c, 0x87, 0x6f, 0x71, 0x96, 0xa1, 0x74, 0x9e, 0x23, 0x00, 0x5a, 0x02, 0x88, 0x90,
	0x94, 0x79, 0x91, 0x90, 0xe4, 0xc2, 0xf5, 0xd9, 0x90, 0x64, 0xb2, 0x03, 0x11, 0xee, 0xea, 0xbf,
	0x15, 0x33, 0x2a, 0xcd, 0x42, 0xf8, 0xa1, 0x4a, 0x63, 0x45, 0xdb, 0x3c, 0x8f, 0x80, 0x23, 0x0b,
	0xae, 0x85, 0xa3, 0x95, 0x98, 0x52, 0xa6, 0x53, 0x3e, 0xfa, 0x72, 0xa7, 0x58, 0x8d, 0x15, 0x0d,
	0x85, 0x98, 0x8a, 0xa9, 0x54, 0xd1, 0x44, 0x8b, 0x49, 0xd8, 0x01, 0x85, 0xb2, 0x24, 0x84, 0x05,
	0xd2, 0xb3, 0x8e, 0x59, 0xb0, 0x3a, 0x84, 0x55, 0x93, 0x95, 0x2c, 0x3c, 0x96, 0x31, 0x27, 0x79,
	0xe3, 0xea, 0x58, 0xc6, 0x2b, 0x1d, 0xc2, 0x91, 0x73, 0x60, 0x01, 0xed, 0x53, 0x28, 0x5a, 0x63,
	0xd7, 0x33, 0x86, 0x43, 0x96, 0xb9, 0x99, 0xe3, 0x3c, 0x8c, 0x15, 0xd5, 0xd4, 0x10, 0x21, 0x61,
	0x1c, 0x66, 0x84, 0x5a, 0x22, 0xbe, 0x91, 0xba, 0x99, 0x07, 0xcb, 0x37, 0x5f, 0xa0, 0x95, 0x08,
	0x42, 0x1d, 0xed, 0xc4, 0x9a, 0x00, 0xa6, 0x5f, 0x6c, 0xd0, 0x83, 0x8a, 0x85, 0x79, 0xc5, 0x8f,
	0x75, 0xe5, 0xa0, 0x3c, 0xa1, 0xdc, 0x82, 0x62, 0xe5, 0x2e, 0x89, 0x7b, 0x23, 0x6c, 0x5a, 0x6c,
	0xd1, 0x69, 0x61, 0xe6, 0x3e, 0x68, 0x3e, 0x18, 0xe5, 0x5f, 0x26, 0x18, 0xc1, 0x8b, 0x04, 0xa3,
	0xbd, 0x3c, 0x64, 0xb9, 0xa1, 0x28, 0xff, 0x96, 0x86, 0xb5, 0xd9, 0x3d, 0x2f, 0xfd, 0x55, 0x02,
	0x8a, 0x35, 0xcb, 0xf5, 0x1c, 0xeb, 0x78, 0x4a, 0x05, 0xbd, 0x09, 0xd9, 0xfe, 0x44, 0xf4, 0xb3,
	0xac, 0x0d, 0x9c, 0xd0, 0x4e, 0xee, 0x08, 0x8a, 0x86, 0xd3, 0x3f, 0xb5, 0x3c, 0xdc, 0xf7, 0xdb,
	0xf8, 0xb5, 0x98, 0x9a, 0xad, 0x84, 0x08, 0xb5, 0x19, 0x36, 0xe8, 0x09, 0xac, 0x91, 0x48, 0xe9,
	0x7a, 0xfe, 0x11, 0x02, 0xeb, 0x5b, 0x77, 0x62, 0xbb, 0x29, 0x23, 0xd3, 0x56, 0x19, 0x1b, 0x71,
	0xe4, 0xf0, 0x55, 0x80, 0x91, 0x61, 0x8d, 0x3d, 0xc3, 0x1a, 0x63, 0xd1, 0xef, 0x87, 0x20, 0x22,
	0x2a, 0x67, 0x82, 0xa8, 0x7c, 0x97, 0x74, 0xdf, 0x41, 0x95, 0x94, 0x65, 0x4a, 0x0c, 0x81, 0x4a,
	0x3f, 0x90, 0x20, 0xd7, 0xb4, 0xfb, 0xc6, 0xf2, 0x8d, 0x52, 0x21, 0x2b, 0x96, 0x92, 0xf8, 0x72,
	0x4b, 0x11, 0xf4, 0x24, 0xa6, 0x4e, 0x0c, 0xef, 0x94, 0xc7, 0x45, 0xfa, 0xbb, 0xe4, 0x41, 0x96,
	0xef, 0x6e, 0x64, 0xc8, 0x3d, 0x82, 0xa2, 0x19, 0xd2, 0xe7, 0x16, 0xd0, 0x1c, 0x1c, 0x4f, 0x4d,
	0x61, 0x43, 0xd0, 0x66, 0xd8, 0x94, 0x46, 0x50, 0x0c, 0xbb, 0x67, 0xe4, 0xd4, 0x2a, 0xe4, 0x86,
	0x7c, 0x77, 0xf8, 0x9b, 0xa1, 0xb7, 0x62, 0x4d, 0x2b, 0xb6, 0x54, 0xf3, 0xc9, 0x95, 0xdf, 0x86,
	0x62, 0xd8, 0x66, 0xd0, 0x2b, 0xb0, 0x55, 0xd1, 0xaa, 0x0d, 0xb5, 0x57, 0xaf, 0xf6, 0x8e, 0xb4,
	0xfa, 0xe5, 0x66, 0xff, 0xe9, 0x37, 0x1e, 0xb1, 0xa6, 0xf8, 0xe9, 0xa3, 0x77, 0xe5, 0x84, 0xf2,
	0x7f, 0x12, 0x6c, 0x46, 0x1d, 0xa5, 0xcf, 0x9e, 0xc3, 0x49, 0xf3, 0xe7, 0x70, 0xcf, 0xa0, 0xd8,
	0xb7, 0xc7, 0x1e, 0x1e, 0x7b, 0xac, 0x38, 0x4c, 0x52, 0x1b, 0x7f, 0x14, 0xff, 0xa8, 0xbe, 0x5c,
	0x65, 0xe4, 0xb4, 0x07, 0x28, 0xf4, 0x83, 0x01, 0xb1, 0xc7, 0xc9, 0x60, 0xa2, 0xf3, 0x63, 0x3e,
	0x9a, 0x08, 0x1b, 0x2b, 0x5a, 0x6e, 0x32, 0x98, 0x1c, 0xe0, 0x0b, 0xd5, 0x54, 0x6a, 0x50, 0x08,
	0xd1, 0x92, 0x05, 0x57, 0x3b, 0xed, 0x5e, 0xbd, 0xdd, 0x8b, 0x3a, 0xaa, 0xbb, 0x09, 0xd7, 0xba,
	0x6a, 0xeb, 0xb0, 0x59, 0xd7, 0x49, 0xc7, 0xad, 0xb6, 0xf7, 0xf5, 0xdf, 0xe9, 0x92, 0x9a, 0x60,
	0x2f, 0x27, 0x0e, 0x12, 0x95, 0x5f, 0xa4, 0x20, 0xc3, 0x8e, 0x69, 0x51, 0x13, 0xd6, 0x5c, 0xcf,
	0x76, 0xe8, 0x0b, 0x63, 0x0a, 0xe1, 0xfd, 0xd4, 0x82, 0x46, 0xa6, 0xcb, 0x70, 0x19, 0x71, 0x63,
	0x45, 0x5b, 0x75, 0xc3, 0x00, 0x54, 0x25, 0xb1, 0x6e, 0x62, 0x0b, 0x56, 0x4b, 0x3f, 0xa9, 0xd0,
	0xf0, 0xc4, 0xf6, 0xf9, 0x80, 0xe3, 0x8f, 0xd0, 0xef, 0xc1, 0x4d, 0x71, 0x4a, 0xaf, 0xcf, 0xc9,
	0x96, 0x8a, 0x2d, 0x9b, 0x76, 0x5d, 0xf0, 0x98, 0x01, 0xa3, 0x16, 0xe9, 0xbe, 0x79, 0xbf, 0x87,
	0x5d, 0xde, 0x11, 0x7f, 0x7d, 0xd9, 0x49, 0x76, 0x39, 0xe8, 0x16, 0xd9, 0xc1, 0x32, 0x9c, 0x04,
	0xed, 0xe3, 0xc7, 0x90, 0xa5, 0x8a, 0x7c, 0xee, 0xf1, 0x4c, 0x7b, 0x6f, 0x19, 0xab, 0x2a, 0x43,
	0xd5, 0x04, 0x0d, 0xea, 0xc1, 0x35, 0xc3, 0x34, 0x2d, 0x62, 0x1d, 0xc6, 0x50, 0xe7, 0x50, 0x52,
	0x8c, 0x24, 0xe3, 0xb2, 0x42, 0x01, 0x3d, 0x07, 0xb9, 0x25, 0x1d, 0xd6, 0xe7, 0x64, 0x8e, 0x38,
	0xc0, 0x7e, 0x14, 0x6e, 0x3f, 0x17, 0x2a, 0x29, 0xe0, 0x13, 0x3a, 0xe2, 0x26, 0x96, 0xc4, 0x14,
	0xa2, 0xfc, 0x9d, 0x44, 0xca, 0x59, 0x5f, 0x75, 0xb3, 0x2f, 0x70, 0xa4, 0xf9, 0x17, 0x38, 0xb7,
	0x20, 0x4f, 0xcd, 0x83, 0x46, 0x07, 0xfe, 0x6e, 0x90, 0x00, 0xda, 0xac, 0x1e, 0x2c, 0x1c, 0x3b,
	0xc6, 0xb8, 0x7f, 0x1a, 0x2a, 0xf7, 0x88, 0x65, 0x30, 0x20, 0x45, 0xb9, 0x05, 0x39, 0xcf, 0x18,
	0xb0, 0xe7, 0x29, 0xfe, 0x3c, 0xeb, 0x19, 0x03, 0xfa, 0xf0, 0x0e, 0x40, 0xdf, 0x1e, 0x8d, 0x2c,
	0x4f, 0x77, 0x4f, 0x0d, 0x96, 0x66, 0x49, 0x03, 0xc2, 0x60, 0xdd, 0x53, 0x63, 0x0f, 0x20, 0xe7,
	0xe0, 0x73, 0x8b, 0x04, 0x4f, 0x45, 0x87, 0xd5, 0x59, 0xbb, 0xb8, 0x01, 0x19, 0xfe, 0x0e, 0x84,
	0x07, 0x6c, 0x36, 0x22, 0x70, 0xfb, 0x98, 0x88, 0x2f, 0xbe, 0xb2, 0x60, 0x23, 0xe2, 0xb2, 0x03,
	0x3c, 0x0e, 0xbf, 0xec, 0x4d, 0x6a, 0x21, 0x88, 0xf2, 0x9f, 0x45, 0xd8, 0xb8, 0x14, 0xc4, 0xc9,
	0xfe, 0xf4, 0xcf, 0x5d, 0x57, 0x77, 0xfb, 0x36, 0xcf, 0x92, 0x09, 0x2d, 0x4f, 0x20, 0x5d, 0x02,
	0x40, 0x4d, 0xc8, 0xb9, 0xf8, 0x1c, 0x93, 0x5a, 0x8f, 0x87, 0x97, 0xb7, 0xe3, 0xa6, 0x87, 0x2e,
	0xa7, 0xd3, 0x7c, 0x0e, 0xa4, 0x7f, 0x14, 0x55, 0x60, 0x8a, 0x1a, 0x54, 0x39, 0x2e, 0x33, 0x56,
	0x02, 0x6a, 0x82, 0xbc, 0xf4, 0xcf, 0x12, 0x64, 0x45, 0xee, 0xdc, 0x84, 0x34, 0x9e, 0xd8, 0xfd,
	0x53, 0xba, 0x4f, 0x69, 0x8d, 0x0d, 0xfc, 0x90, 0x9f, 0x98, 0x7d, 0x11, 0x2c, 0xf6, 0x5b, 0x14,
	0xef, 0x62, 0x8c, 0x3a, 0xbc, 0x78, 0x4f, 0xd3, 0x55, 0x7e, 0xf4, 0x82, 0x49, 0x50, 0xfc, 0x0f,
	0x0a, 0x7b, 0xe5, 0x1d, 0x28, 0x84, 0x80, 0x08, 0x20, 0xd3, 0xee, 0x68, 0xad, 0x4a, 0x53, 0x5e,
	0x41, 0x05, 0xc8, 0xb6, 0xd4, 0xb6, 0xda, 0x3a, 0x6a, 0xc9, 0x12, 0x1d, 0x54, 0x9e, 0xd2, 0x41,
	0xa2, 0xf4, 0xcb, 0x24, 0x64, 0xd8, 0x5a, 0x17, 0x67, 0xec, 0xad, 0xa0, 0x0b, 0x67, 0x47, 0xdf,
	0x7e, 0x57, 0x6d, 0xc0, 0xe6, 0xc8, 0x1a, 0xeb, 0xc6, 0xc9, 0x09, 0xee, 0x93, 0xae, 0x56, 0x24,
	0xf6, 0xcc, 0x97, 0x4b, 0xec, 0x68, 0x64, 0x8d, 0x2b, 0x9c, 0x97, 0xd8, 0x6c, 0x32, 0x85, 0xf1,
	0xfc, 0xf2, 0x14, 0xd9, 0x2f, 0x3b, 0x85, 0xf1, 0x7c, 0x7e, 0x8a, 0x7b, 0xb0, 0x2a, 0x2c, 0x26,
	0xe4, 0x58, 0x5a, 0x51, 0x00, 0xa9, 0x6f, 0xcd, 0x95, 0x3f, 0xf9, 0x4b, 0xe5, 0x0f, 0x32, 0x61,
	0xed, 0xc4, 0x7a, 0x8e, 0x4d, 0xdd, 0xcf, 0xf2, 0x69, 0x2a, 0xe3, 0xc7, 0x5f, 0xaa, 0xa3, 0xf2,
	0xb3, 0xfe, 0x2a, 0x65, 0xea, 0xd7, 0x55, 0x5f, 0x83, 0x22, 0xdf, 0x7d, 0x96, 0x83, 0x81, 0x09,
	0xc2, 0x61, 0x84, 0x4f, 0xe9, 0x7f, 0x24, 0xd8, 0x8c, 0xea, 0xce, 0x88, 0x89, 0xfa, 0x79, 0x3b,
	0xcf, 0xcf, 0xe0, 0xc2, 0x0e, 0x97, 0x7a, 0x69, 0x87, 0x9b, 0xf5, 0xee, 0xf4, 0xbc, 0x77, 0x3f,
	0x83, 0x55, 0x21, 0xbc, 0xe5, 0xba, 0x53, 0xcc, 0xdf, 0x40, 0xbf, 0x1b, 0x77, 0x46, 0x5e, 0x19,
	0xa9, 0x84, 0x56, 0x13, 0xfb, 0x40, 0x47, 0xa5, 0x1f, 0x26, 0xa0, 0x18, 0x7e, 0x8c, 0xbe, 0x0d,
	0x1b, 0xbe, 0xd1, 0xf8, 0x1a, 0x91, 0x7e, 0x15, 0x1a, 0x91, 0x05, 0x5f, 0x5f, 0x29, 0x97, 0x55,
	0x9f, 0xf8, 0x35, 0xa8, 0xfe, 0x92, 0x9d, 0x26, 0x2f, 0xdb, 0x69, 0xe9, 0xa7, 0x12, 0x5c, 0x8f,
	0xe4, 0x16, 0xcb, 0xbf, 0x13, 0xb3, 0xfe, 0x1d, 0xaa, 0xd5, 0x53, 0x2f, 0x57, 0xab, 0x2b, 0xdf,
	0x82, 0x9c, 0xb0, 0x17, 0xb4, 0x05, 0x9b, 0xdd, 0xfa, 0x93, 0xba, 0xa6, 0xf6, 0x9e, 0xcd, 0x55,
	0x6e, 0x22, 0x50, 0x55, 0x9a, 0xac, 0x5c, 0x6d, 0x76, 0x3e, 0x65, 0xaf, 0xa6, 0x5a, 0xf5, 0x9a,
	0x7a, 0xd4, 0x92, 0x93, 0x28, 0x07, 0xa9, 0x86, 0xba, 0xdf, 0x90, 0x53, 0xa8, 0x08, 0xb9, 0xaa,
	0xa6, 0xf6, 0xd4, 0x6a, 0xa5, 0x29, 0xa7, 0x95, 0xff, 0x4a, 0xc0, 0xea, 0x4c, 0x5d, 0x40, 0x5a,
	0xe2, 0xfe, 0xd0, 0x9e, 0x9a, 0x3a, 0xc9, 0xaf, 0x5c, 0xf3, 0x0b, 0xca, 0x9c, 0x2a, 0xc1, 0x0b,
	0x92, 0x38, 0xe7, 0x40, 0x73, 0xa7, 0x78, 0x82, 0xaa, 0x90, 0x19, 0x60, 0xc7, 0xb1, 0xc4, 0xcb,
	0x90, 0x05, 0xa7, 0x00, 0xfb, 0x14, 0x67, 0x9e, 0x0f, 0x27, 0x45, 0x1f, 0x42, 0x72, 0x60, 0x79,
	0xbc, 0x87, 0x7b, 0x7d, 0x01, 0x87, 0xcb, 0xe4, 0x84, 0x08, 0xed, 0x43, 0x86, 0x9e, 0x84, 0x89,
	0x5c, 0xb6, 0x13, 0xa3, 0x38, 0x2a, 0x37, 0x29, 0x05, 0xab, 0xda, 0x38, 0x79, 0xe9, 0x03, 0x28,
	0x84, 0xc0, 0x2f, 0xf2, 0x66, 0x9f, 0x74, 0xcb, 0xbc, 0x44, 0x53, 0x7e, 0x26, 0x41, 0xb1, 0x32,
	0xb4, 0x0c, 0x57, 0xec, 0xf7, 0x47, 0x3c, 0xa1, 0xb1, 0xd7, 0x00, 0x0b, 0x0e, 0x7c, 0xc3, 0x14,
	0xe1, 0x53, 0xa9, 0x88, 0xec, 0xa9, 0x7c, 0xb2, 0xf4, 0xc0, 0x2f, 0x0f, 0xe9, 0xc7, 0xea, 0x53,
	0xfa, 0x0e, 0x9e, 0x58, 0x4d, 0xe7, 0x09, 0x3d, 0x93, 0x4b, 0x10, 0x78, 0xa7, 0xd7, 0xa8, 0x6b,
	0x72, 0x4a, 0xf9, 0x07, 0x09, 0x6e, 0x44, 0xab, 0x16, 0xbd, 0x07, 0x59, 0x5a, 0x87, 0xf1, 0x1a,
	0x6d, 0xe1, 0xa7, 0x1c, 0x84, 0x52, 0x35, 0xb5, 0x8c, 0x43, 0xff, 0x93, 0x0a, 0x4d, 0x24, 0xf0,
	0x70, 0x9f, 0x02, 0x02, 0xa8, 0x9a, 0x48, 0x85, 0x55, 0x83, 0x2c, 0x52, 0xd4, 0xb2, 0x5c, 0xd9,
	0xca, 0xd5, 0xfb, 0xd1, 0x58, 0xd1, 0x8a, 0x46, 0x68, 0x3c, 0x53, 0xae, 0xfd, 0x52, 0x82, 0x6b,
	0x11, 0xb6, 0x85, 0xbe, 0x02, 0xb9, 0x53, 0xdb, 0xf5, 0x42, 0x6e, 0x9d, 0x25, 0x63, 0xe2, 0xd7,
	0xaf, 0xc1, 0x1a, 0x33, 0x3b, 0x9d, 0xd7, 0x9f, 0xe2, 0x9b, 0x47, 0x06, 0x15, 0xdf, 0xda, 0xcd,
	0xad, 0x29, 0x19, 0x67, 0x4d, 0xa9, 0x5f, 0xc9, 0x9a, 0xea, 0x20, 0xcf, 0x1b, 0x7b, 0xc4, 0x71,
	0xf0, 0x9d, 0x88, 0x3d, 0x0f, 0x4b, 0xa7, 0x7c, 0x07, 0x32, 0x4c, 0x4d, 0xa8, 0x05, 0xeb, 0xa2,
	0xf8, 0x9e, 0xd5, 0xee, 0xbd, 0xe5, 0xdf, 0xea, 0x52, 0x6a, 0xd2, 0xcb, 0x4d, 0xc2, 0x00, 0x84,
	0x20, 0x39, 0x0d, 0x69, 0x99, 0x0c, 0xf6, 0x52, 0x90, 0xb0, 0x4c, 0xe5, 0x00, 0x56, 0x67, 0x68,
	0x5f, 0xa6, 0xec, 0xdf, 0xfd, 0x4b, 0x19, 0xb2, 0xfb, 0x4c, 0x3c, 0xf4, 0x63, 0x09, 0x56, 0x67,
	0x3e, 0x76, 0x47, 0xdb, 0x8b, 0xe2, 0xcc, 0xe5, 0xdb, 0x13, 0xa5, 0x2b, 0xbf, 0x8a, 0x55, 0x1e,
	0xfe, 0xe0, 0x9f, 0xfe, 0xe5, 0x27, 0x89, 0x37, 0xd1, 0x1b, 0x3b, 0xfe, 0x1d, 0x9a, 0xef, 0x11,
	0xa1, 0x3e, 0x16, 0x5f, 0x2b, 0xef, 0x6c, 0xef, 0x84, 0x3e, 0x9c, 0xdd, 0xd9, 0xfe, 0x1c, 0xfd,
	0x85, 0x04, 0xeb, 0x73, 0xdf, 0xe6, 0xa2, 0x05, 0x71, 0x34, 0xfa, 0x96, 0x46, 0xe9, 0xad, 0x98,
	0xd8, 0xec, 0x53, 0xdb, 0x48, 0x19, 0xd9, 0x27, 0xa8, 0x21, 0x29, 0x3f, 0x0f, 0x8b, 0x89, 0xfe,
	0x44, 0x02, 0x79, 0xfe, 0x72, 0x06, 0x5a, 0xf4, 0x46, 0x39, 0xfa, 0x12, 0x47, 0xe9, 0xc6, 0xa5,
	0x13, 0xc3, 0xfa, 0x68, 0xe2, 0x5d, 0x08, 0x71, 0xb6, 0x5f, 0x60, 0xcb, 0x7e, 0x2e, 0x81, 0x3c,
	0x7f, 0xf9, 0x63, 0x91, 0x38, 0x0b, 0x2e, 0x89, 0xc4, 0xd0, 0xe5, 0xc7, 0x54, 0xb0, 0xf7, 0x95,
	0xf8, 0xfb, 0xf4, 0x61, 0xf8, 0xe6, 0x06, 0x11, 0x72, 0xfe, 0xae, 0xc8, 0x22, 0x21, 0x17, 0xdc,
	0x29, 0x89, 0x2f, 0xe4, 0x6e, 0xfc, 0xdd, 0x9b, 0x11, 0xf2, 0xcf, 0x24, 0x7a, 0xd1, 0x69, 0xf6,
	0xf2, 0x07, 0x2a, 0xc7, 0xf0, 0x89, 0xd0, 0xe5, 0x86, 0xd2, 0x92, 0x2f, 0xd5, 0x95, 0xf7, 0xa9,
	0x80, 0x0f, 0xd1, 0x4e, 0x6c, 0x01, 0x77, 0xd8, 0xb7, 0xed, 0x3f, 0x91, 0x60, 0x7d, 0xee, 0x0b,
	0xea, 0x45, 0x7e, 0x11, 0xfd, 0xa1, 0x75, 0x69, 0xf9, 0x1b, 0x7b, 0xe5, 0x1d, 0x2a, 0xd9, 0x5b,
	0xca, 0x83, 0x2b, 0xf4, 0xeb, 0x7f, 0x3f, 0xfe, 0xa1, 0xb4, 0x4d, 0xa5, 0x9a, 0xfb, 0x86, 0x7c,
	0x91, 0x54, 0xd1, 0x9f, 0x9a, 0xc7, 0x94, 0x6a, 0xf7, 0xc1, 0xb2, 0xfd, 0xf2, 0x45, 0x22, 0xfa,
	0x94, 0xb6, 0xd1, 0x73, 0xc8, 0xf2, 0x8b, 0x3e, 0xe8, 0xd5, 0x85, 0xba, 0x8b, 0xab, 0xb1, 0x37,
	0xa9, 0x04, 0xaf, 0xa1, 0x7b, 0x4b, 0x24, 0xa0, 0x2a, 0x22, 0xae, 0xf8, 0x23, 0x09, 0xf2, 0xfe,
	0x4d, 0x06, 0xf4, 0xfa, 0xe2, 0x48, 0x14, 0xbe, 0x2e, 0x54, 0xba, 0x7f, 0x25, 0x1e, 0x8f, 0x55,
	0x51, 0xb2, 0x44, 0xe8, 0x88, 0x59, 0xcc, 0x67, 0x00, 0xc1, 0xc5, 0x20, 0x74, 0x7f, 0x59, 0x78,
	0x0a, 0xef, 0xc5, 0xa2, 0xc0, 0xc4, 0xe7, 0xde, 0x8e, 0xb5, 0x0f, 0x5f, 0x48, 0x00, 0xc1, 0x65,
	0xa3, 0x45, 0x93, 0x5f, 0xba, 0x8e, 0xb4, 0x54, 0x11, 0x3c, 0x32, 0x2a, 0x71, 0x16, 0xff, 0x21,
	0xbb, 0x22, 0x44, 0xc4, 0x08, 0x2e, 0x1f, 0x2d, 0x12, 0xe3, 0xd2, 0xf5, 0xa4, 0x38, 0x62, 0xec,
	0xc6, 0xd9, 0x07, 0x2e, 0xc6, 0xdf, 0x4a, 0xec, 0x5a, 0xe4, 0xdc, 0x55, 0x1b, 0xf4, 0xf6, 0x72,
	0xbd, 0x47, 0xe4, 0xb6, 0x87, 0x2f, 0x40, 0xc1, 0x6d, 0x26, 0x4e, 0xc4, 0x11, 0xf2, 0x86, 0x43,
	0xcf, 0xee, 0x17, 0x29, 0x58, 0xe7, 0x85, 0x82, 0xb8, 0x9f, 0x84, 0x9e, 0xc3, 0xea, 0xcc, 0xa5,
	0xd1, 0x45, 0xf5, 0x42, 0xd4, 0xcd, 0xd2, 0x85, 0x96, 0x75, 0x8f, 0x4a, 0x78, 0x5b, 0xb9, 0xb5,
	0x58, 0xc2, 0xcf, 0xd1, 0x05, 0x40, 0x70, 0x05, 0x75, 0x91, 0x26, 0x2f, 0x5d, 0x52, 0x2d, 0x2d,
	0xbf, 0x36, 0x25, 0xa6, 0x46, 0x4b, 0xa7, 0xfe, 0x23, 0x09, 0x8a, 0xe1, 0x5b, 0x5a, 0xe8, 0x8d,
	0xc5, 0x5a, 0x98, 0xbb, 0xf9, 0x5a, 0xda, 0x8e, 0x83, 0xca, 0x35, 0x55, 0xa2, 0xc2, 0x6c, 0x22,
	0xb4, 0x13, 0xbe, 0x71, 0xec, 0x6f, 0xfc, 0xcc, 0x6d, 0xd7, 0x45, 0x1b, 0x1f, 0x75, 0x25, 0xf6,
	0xaa, 0x8d, 0xdf, 0x5e, 0xb6, 0xfa, 0xbd, 0xfc, 0xef, 0x66, 0xf9, 0x4c, 0xc7, 0x19, 0x4a, 0xff,
	0xce, 0xff, 0x07, 0x00, 0x00, 0xff, 0xff, 0xb4, 0x39, 0xa5, 0x5c, 0x12, 0x3d, 0x00, 0x00,
}
